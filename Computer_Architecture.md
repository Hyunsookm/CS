# Computer Architecture
## 컴퓨터구조와 개요 (Introduction to Computer Architecture)
#### 컴퓨터 구조란 무엇인가
- 정의: 컴퓨터 시스템의 구성 요소와 그들 간의 상호작용을 설명하는 개념.
#### 컴퓨터 시스템의 발전과 역사
//??
#### 컴퓨터의 구성 요소 (Components of a Computer System)

##### 중앙처리장치(CPU), 메모리, 입출력 장치 (I/O Devices)
- 정의: 
  - 중앙처리장치(CPU)는 컴퓨터의 두뇌로서, 메모리에 저장된 명령어를 읽어들이고, 읽어들인 명령어를 해석하고, 실행하는 부품이다.
  - 메모리(Memory)는 일반적으로 RAM(Random Access Memory)을 지칭하고, 현재 실행되는 프로그램의 명령어와 데이터를 저장하는 부품이다.
  - 입출력 장치(I/O Devices)는 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환할 수 있는 부품이다.
- 특징:
  - 컴퓨터를 이루는 핵심 부품이다.
  - 메모리에서는 주소 개념을 사용하여 명령어에 접근한다.
  - CPU 내부에는 여러가지 부품이 존재한다.
  - 입출력장치의 예로는 마우스, 키보드, 모니터 등이 있다.
#### 폰 노이만 아키텍처 (Von Neumann Architecture) vs. 하버드 아키텍처 (Harvard Architecture)
- 정의: 
  - 폰 노이만 아키텍처: 1945년 수학자이자 물리학자인 존 폰 노이만이 제안한 컴퓨터 구조.
  - 하버드 아키텍처: 하버드 대학교에 납품된 세계 최초의 범용 컴퓨터 하버드 마크 I에서 나온 컴퓨터 구조.
- 특징:
  ![image](/image/von.png)
  ![image](/image/havard.png)
https://daeun28.github.io/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%B5%ED%95%99-%EC%8A%A4%ED%84%B0%EB%94%94/post19/
    - 폰 노이만 아키텍처는 프로그램 내장 방식으로, 프로그램과 데이터를 동일한 메모리에 저장한다.
    - 명령어와 데이터는 같은 시스템 버스와 메모리를 사용하기 때문에 동시에 접근하는 것은 불가능하다.
    - CPU는 한 번에 하나의 명령어만 실행 가능하고, 명령어 실행은 반드시 메모리에서 수행.
  
    - 하버드 아키텍처는 폰 노이만 병목현상을 개선하기 위해 명령어와 데이터 메모리가 분리되어 취급된다.
    - 명령어, 데이터 메모리의 시스템 버스가 각각 존재하고, RISC의 명령어 구조를 따른다.
    - 명령어와 데이터 메모리가 분리되어 있기 때문에 명령어와 데이터가 다른 비트 수 기반을 가질 수 있다.
- 장점:
  - 폰 노이만 아키텍처는 프로그램 내장 방식을 적용했기 때문에 하드웨어를 재설정할 필요가 없이 소프트웨어만 교체하면 되므로 범용성이 크게 향상된다.
  - 공용 시스템 버스와 메모리를 사용하기 때문에 설계가 단순하고, 비용이 저렴하다.
  
  - 하버드 아키텍처는 명령어를 읽는 동시에 데이터를 읽거나 쓸 수 있어 성능이 우수하다.
  - 폰 노이만 병목현상이 적어 명령의 처리를 끝내자마자 다음의 명령을 읽어들일 수 있기 때문에 더 빠른 속도를 낼 수 있다.
  
- 단점:
  - 폰 노이만 아키텍처는 한 번에 하나의 명령어만 처리해서 CPU를 효율적으로 사용할 수 없다.
  - CPU와 메모리의 속도 차이로 인해 병목 현상이 발생하게 되어 성능 저하를 유발할 수 있다.
 
  - 하버드 아키텍처는 버스 시스템이 복잡하고, 설계가 어렵다.
  - 메모리와 데이터 메모리의 비트 수가 다를 경우 주소를 변경하는 과정을 거쳐야 한다.

#### 컴퓨터 설계의 기본 원리 (Fundamental Principles of Computer Design)
- 특징:
  1. 성능: 시스템의 처리 속도와 효율성을 높이기 위한 설계 원칙이다. 이를 위해 파이프라이닝, 캐시 메모리, 병렬 처리 등의 기술을 활용한다.

  2. 비용(Cost): 경제적인 설계를 목표로 하며, 자원과 비용을 최적화하여 효율적인 시스템을 구축하는 것을 의미한다. 불필요한 기능이나 자원 낭비를 최소화한다.

  3. 신뢰성(Reliability): 시스템이 오류 없이 안정적으로 작동할 수 있도록 설계한다. 오류 검출 및 수정 메커니즘을 포함하여 시스템의 신뢰성을 높인다.

  4. 유연성(Flexibility): 시스템이 다양한 요구와 환경 변화에 적응할 수 있도록 설계한다. 이를 통해 하드웨어와 소프트웨어의 업그레이드가 용이하도록 한다.

  5. 확장성(Scalability): 시스템이 성장하거나 변화하는 요구에 따라 쉽게 확장될 수 있도록 설계한다. 추가적인 하드웨어나 소프트웨어를 쉽게 통합할 수 있는 구조이다.

  6. 모듈화(Modularity): 시스템을 독립적인 모듈로 나누어 설계하여 복잡성을 줄이고 유지보수를 용이하게 한다. 각 모듈은 특정 기능을 담당한다.

  7. 추상화(Abstraction): 복잡한 시스템을 단순화하여 핵심 개념만을 다루는 원리이다. 하드웨어와 소프트웨어 간의 인터페이스를 정의하여 사용자가 시스템을 쉽게 이해하고 사용할 수 있도록 한다.

  8. 계층 구조(Hierarchy):시스템을 여러 계층으로 나누어 각 계층이 특정 기능을 담당하게 하여 복잡성을 관리한다. 예를 들어, 하드웨어, 운영체제 및 응용 프로그램 계층으로 구분한다.

## 명령어 집합 구조(ISA, Instruction Set Architecture)
- 정의: 
  - CPU가 이해할 수 있는 명령어들의 모음
#### CISC (Complex Instruction Set Computer)
- 정의: 복잡한 명령어 집합을 가진 컴퓨터 아키텍처로, 여러 가지 작업을 수행할 수 있는 복잡한 명령어를 제공하도록 설계되었다.
- 특징:
  - 가변 길이의 명령어를 사용한다.
  - 적은 수의 명령어로도 프로그램을 작성할 수 있다.
- 장점:
  - 적은 수의 명령어를 사용하므로, 메모리 공간을 절약할 수 있다.
- 단점:
  - 명령어의 크기와 프로그램이 실행되기까지의 시간이 일정하지 않다.
  - 하나의 명령어를 실행하는 데에 여러 클럭 주기를 필요로 한다.
  - 명령어 파이프라인을 구현하는 데 어려움이 있다.
- 예시:
  - x86, x86-64
#### RISC (Reduced Instruction Set Computer)
- 정의: 간단하고 효율적인 명령어 집합을 가진 컴퓨터 아키텍처로, 대부분의 명령어가 단순하고 빠르게 실행될 수 있도록 설계되었다.
- 특징:
  - 고정 크기의 명령어를 사용한다.
  - 메모리에 직접 접근하는 명령어를 load, store로 제한하여, 메모리 접근을 단순화하고 최소화를 추구한다.
  - 레지스터를 이용한 연산이 많다.   
- 장점:
  - 명령어 파이프라인을 구현하기 쉽다.
  - 간단한 명령어 처리로 전력 소모가 적다.
- 단점:
  - 프로그램을 이루는 명령어의 수가 많다.
- 예시:
  - ARM

## 데이터 표현 및 연산 (Data Representation and Operations)

#### 수의 체계 (Number Systems)

##### 이진수(Binary), 8진수(Octal), 16진수(Hexadecimal) 표현
- 정의: 
  - 이진수(Binary): 0과 1만으로 모든 숫자를 표현하는 이진법으로 표현한 수.
  - 8진수(Octal): 0부터 7까지의 수로 모든 숫자를 표현하는 8진법으로 표현한 수.
  - 16진수(Hexadecimal) 0부터 9, A부터 F로 모든 숫자를 표현하는 16진법으로 표현한 수.
- 특징:
  - 이진수는 한 글자당 1비트, 8진수는 3비트, 16진수는 4비트가 필요하다.
  - 이진수 앞에는 0b를 표기하거나, 끝에 아래첨자(2)를 붙인다.
  - 16진수 앞에는 0x를 표기하거나, 끝에 아래첨자(16)을 붙인다.
  - 이진수의 음수는 그 수의 2의 보수로 표현한다. 모든 0과 1을 뒤집은 후, 1을 더해준다.
      ![image](/image/2complement.png)
      강민철. (2022). *혼자 공부하는 컴퓨터구조 + 운영체제* (p.59). 한빛미디어.

##### 체계 간 변환
- 16진수 -> 2진수
  - 16진수 각 자리의 수를 4비트의 이진수로 간주하여, 따로따로 4비트의 이진수로 변경 후 잇는다.
      ![image](/image/16to2.png)

      강민철. (2022). *혼자 공부하는 컴퓨터구조 + 운영체제* (p.62). 한빛미디어.
- 2진수 -> 16진수
  - 2진수의 4자리를 하나의 16진수로 간주하여, 뒤에서부터 4자리 씩 변환한다.
      ![image](/image/2to16.png)
      
      강민철. (2022). *혼자 공부하는 컴퓨터구조 + 운영체제* (p.63). 한빛미디어.

#### 정수와 실수 표현 (Integer and Floating-Point Representation)
- 정의: 
  - 정수(Integer): 숫자를 표현하기 위한 데이터 타입 중 하나로, 소수점 없는 숫자를 저장하고 처리한다.
  - 실수(Real Number): 소수점 이하의 값을 포함할 수 있는 숫자 집합으로, 정수, 유리수, 무리수를 모두 포함하는 확장된 수의 개념이다.
##### 고정소수점과 부동소수점
- 정의: 
  - 고정소수점(Fixed Point): 소수점의 위치가 고정되어 있는 숫자 표현 방식이다.
  - 부동소수점(Floating Point): 소수점 위치가 고정되어 있지 않고, 숫자의 크기에 따라 소수점 위치가 이동하는 표현 방식이다.
- 특징:
  - 고정 소수점은 정수 부분과 소수 부분의 비율이 일정하다.
  - 고정된 자리 수로 인해 특정 숫자를 정확하게 표현할 수 있다.
  - 표현할 수 있는 값의 범위가 제한적이다.
  - 부동 소수점은 매우 큰 수나 매우 작은 수를 표현할 수 있게 해준다.
  - 일반적으로 가수와 지수로 나누어 표현한다.
- 장점:
  - 고정 소수점은 연산 속도가 빠르고, 메모리 사용이 효율적이다.
  - 부동 소수점은 표현할 수 있는 수의 범위가 넓다.
- 단점:
  - 고정 소수점은 표현할 수 있는 숫자의 범위가 좁아서 큰 숫자나 소수를 표현하기 어렵다.
  - 부동 소수점은 연산 속도가 느리고, 메모리 사용량이 많을 수 있다.

##### IEEE 754 표준 (IEEE 754 Standard) - 표현, 정밀도, 반올림
- 정의: 
  - 컴퓨터에서 부동 소수점을 표현하고 계산하기 위한 국제 표준.
1. 표현(Expression): 부동 소수점 표현의 구성 요소.
    - 부호 비트
      - 1비트의 크기를 가지고, 실수의 부호를 결정한다.
    - 지수부(Exponent)
      - 지수를 나타낸다.
    - 가수부(Significand)
      - 유효 숫자를 나타낸다.
2. 정밀도(Precision): 부동 소수점 수가 표현할 수 있는 숫자의 정확도.
    - 단정밀도(Single Precision)
      - 실수를 32비트(4바이트)로 표현하며 부호 1비트, 지수부 8비트, 가수부 23비트로 구성
    - 배정밀도(Double Precision)
      - 실수를 64비트(8바이트)로 표현하며 부호 1비트, 지수부 11비트, 가수부 52비트로 구성

3. 반올림(Rounding): 부동 소수점 연산에서 발생할 수 있는 반올림을 다루기 위한 다양한 방법 정의.
    - 가장 가까운 짝수로 반올림 (Round to Nearest, Even)
      - 가장 가까운 값으로 반올림하며, 동일한 거리의 경우 짝수로 반올림한다.
    - 올림 (Round Up)
      - 항상 다음 큰 값으로 반올림한다.
    - 내림 (Round Down)
      - 항상 다음 작은 값으로 반올림한다.
    - 정확한 반올림 (Round Toward Zero)
      - 절대값이 더 작은 방향으로 반올림한다.
       

#### 데이터 연산 (Data Operations)
- 정의:
  - CPU의 ALU에서 수행되는 기본적인 데이터를 처리하는 기본적인 연산.
##### 산술 연산 (Arithmetic Operations)
- 정의: 
  - 숫자에 대한 기본적인 수학적 연산으로, 일반적으로 정수 및 부동 소수점 수에 대해 수행된다.
- 특징: 
  - 기본적인 사칙연산 덧셈, 뺄셈, 곱셈, 나눗셈을 수행한다.
  - 오버플로우, 언더플로우와 같은 문제를 처리하기 위한 추가적인 논리가 필요하다.
##### 논리 연산 (Logical Operations)
- 정의: 
  - 비트 단위로 수행되는 논리적 판단을 나타내며, 주로 불리언 값 또는 비트 패턴에 적용된다.
- 특징:
  - 기본적인 비트 연산인 AND, OR, NOT, XOR을 수행한다.
  - 조건문, 비트 마스크, 플래그 설정 등에 활용된다.
  - ALU는 데이터의 비교 및 제어를 가능하게 한다.
##### 시프트 연산 (Shift Operations)
- 정의: 
  - 비트의 위치를 왼쪽 또는 오른쪽으로 이동시키는 연산이다.
- 특징: 
  - 왼쪽 시프트, 오른쪽 시프트, 산술 시프트, 논리 시프트를 수행한다.
  - 곱셈 및 나눗셈을 효율적으로 수행할 수 있는 방법을 제공한다.
  - 비트 필드를 조작한거나 특정 비트 패턴을 추출하는 데 사용한다.

#### Signed vs. Unsigned 데이터
- 정의: 
  - 정수를 표현할 때 사용하는 방식으로, 정수에 부호가 존재하면 Signed, 존재하지 않으면 Unsigned라고 한다.
- 특징:
  - Signed 정수는 양수,음수를 모두 표현할 수 있고, 최상위 비트를 부호 비트로 사용한다.
  - 최상위 비트가 0이면 양수, 1이면 음수를 나타낸다.
  - N비트의 signed 정수는 -2^n ~ 2^n -1 까지의 수를 표현할 수 있다.
  - Unsigned 정수는 양수와 0만 표현할 수 있으므로, 모든 비트를 숫자 값으로 사용한다.
  - N비트의 Unsigned 정수는 0부터 2^n -1까지의 수를 표현할 수 있다.
  
## 중앙처리장치 (CPU, Central Processing Unit)
- 정의: 
  - 컴퓨터 시스템의 핵심 구성 요소로, 프로그램의 명령어를 해석하고 실행하는 역할을 한다.

#### CPU의 구조와 구성 요소 (CPU Architecture and Components)
- 특징:
  - CPU는 산술 논리장치(ALU, Arithmetic Logic Unit), 제어 장치(CU, Control Unit), 레지스터(Register) 등으로 구성된다.
  - 명령어 사이클을 통해 순서대로 명령어를 처리한다.
##### 산술 논리 장치(ALU, Arithmetic Logic Unit)
- 정의: 
  - 산술 연산(덧셈, 뺄셈 등)과 논리 연산(AND, OR, NOT 등)을 수행합니다.
- 특징:
  - 
##### 레지스터 (Registers)
- 정의: 
  - 
- 특징:
  - 
##### 제어 유닛(Control Unit)
- 정의: 
  - CPU의 다른 구성 요소 간의 작업을 조정하고 명령어의 실행 순서를 제어한다.
- 특징:
  - 
#### 명령어 사이클 (Instruction Cycle)

##### 명령어 인출(Fetch), 해독(Decode), 실행(Execute), 메모리접근(Memory Access), ...

#### 메모리 접근 방식 (Memory Access Methods)

## 메모리 구조 (Memory Architecture)
#### 메모리 계층 구조 (Memory Hierarchy)
#### 캐시 메모리 (Cache Memory)

##### 직접 매핑(Direct Mapping)
##### 집합 연관(Set-Associative)
##### 완전 연관(Fully Associative)
##### 캐시 적중률(Cache Hit Rate)

#### 가상 메모리 (Virtual Memory)

##### 페이징(Paging)
##### 세그멘테이션(Segmentation)
##### 페이지 교체 알고리즘
###### LRU
###### FIFO
###### 최적 교체(Optimal Replacement)

#### TLB (Translation Lookaside Buffer)

## 입출력 시스템 (I/O Systems)

#### 입출력 장치와 동작 원리 (I/O Devices and Operations)
#### 입출력 제어 방식 (I/O Control Mechanisms)

##### 프로그램 제어(Programmed I/O)
##### 인터럽트 방식(Interrupt-driven I/O)
##### DMA(Direct Memory Access)

#### 인터럽트 (Interrupts)
#### I/O 버스와 데이터 전송 (I/O Bus and Data Transfer)

## 프로세서 설계 (Processor Design)

#### 데이터 경로 설계 (Datapath Design)

##### 단일 사이클(Single-Cycle Design)

##### 멀티 사이클(Multi-Cycle Design)

#### 파이프라인 처리 (Pipelining)
##### 파이프라인의 개념과 이점
##### 위험 요소(Hazards)

## 성능 평가와 최적화 (Performance Evaluation and Optimization)

#### 성능 측정 지표 (Performance Metrics)

##### 처리량(Throughput), 응답 시간(Response Time), 클럭 주기(Clock Cycle)

#### Amdahl의 법칙 (Amdahl's Law)

#### 시스템 성능 최적화 (System Performance Optimization)

##### 캐시 최적화(Cache Optimization)
##### 분기 예측(Branch Prediction)