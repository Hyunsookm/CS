# Computer Architecture
## 컴퓨터구조와 개요 (Introduction to Computer Architecture)
#### 컴퓨터 구조란 무엇인가
- 정의: 컴퓨터 시스템의 구성 요소와 그들 간의 상호작용을 설명하는 개념.
#### 컴퓨터 시스템의 발전과 역사
1. 초기 계산 기계 (1940년대 이전)
     - 아날로그 컴퓨터 사용
2. 최초의 전자 컴퓨터 (1940년대)
     - ENIAC (Electronic Numerical Integrator and Computer): 세계 최초의 범용 전자 컴퓨터
3. 트랜지스터와 통합 회로의 시대 (1950년대~1960년대)
     - 진공관을 대체한 트랜지스터를 사용한 컴퓨터
     - IC회로의 도입
4. 미니컴퓨터와 개인용 컴퓨터의 발전 (1970년대)
     - 개인용 컴퓨터(PC, Personnal Computer)의 도입
5. 네트워킹과 인터넷의 발전 (1980년대)
     - LAN(Local Area Network)을 통해 인터넷 상용화

6.  모바일 컴퓨팅과 클라우드 컴퓨팅 (2000년대)
     - 모바일 장치 및 클라우드 컴퓨팅으로 어디서나 데이터에 접근할 수 있음.

7.  인공지능과 머신러닝의 발전 (2010년대~현재)
     - 머신러닝과 딥러닝 기술의 발전으로 컴퓨터가 데이터를 학습하고 패턴을 인식한다.
#### 컴퓨터의 구성 요소 (Components of a Computer System)

##### 중앙처리장치(CPU), 메모리, 입출력 장치 (I/O Devices)
- 정의: 
  - 중앙처리장치(CPU)는 컴퓨터의 두뇌로서, 메모리에 저장된 명령어를 읽어들이고, 읽어들인 명령어를 해석하고, 실행하는 부품이다.
  - 메모리(Memory)는 일반적으로 RAM(Random Access Memory)을 지칭하고, 현재 실행되는 프로그램의 명령어와 데이터를 저장하는 부품이다.
  - 입출력 장치(I/O Devices)는 컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환할 수 있는 부품이다.
- 특징:
  - 컴퓨터를 이루는 핵심 부품이다.
  - 메모리에서는 주소 개념을 사용하여 명령어에 접근한다.
  - CPU 내부에는 여러가지 부품이 존재한다.
  - 입출력장치의 예로는 마우스, 키보드, 모니터 등이 있다.
#### 폰 노이만 아키텍처 (Von Neumann Architecture) vs. 하버드 아키텍처 (Harvard Architecture)
- 정의: 
  - 폰 노이만 아키텍처: 1945년 수학자이자 물리학자인 존 폰 노이만이 제안한 컴퓨터 구조.
  - 하버드 아키텍처: 하버드 대학교에 납품된 세계 최초의 범용 컴퓨터 하버드 마크 I에서 나온 컴퓨터 구조.
- 특징:
  ![image](/image/von.png)
  ![image](/image/havard.png)
https://daeun28.github.io/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B3%B5%ED%95%99-%EC%8A%A4%ED%84%B0%EB%94%94/post19/
    - 폰 노이만 아키텍처는 프로그램 내장 방식으로, 프로그램과 데이터를 동일한 메모리에 저장한다.
    - 명령어와 데이터는 같은 시스템 버스와 메모리를 사용하기 때문에 동시에 접근하는 것은 불가능하다.
    - CPU는 한 번에 하나의 명령어만 실행 가능하고, 명령어 실행은 반드시 메모리에서 수행.
  
    - 하버드 아키텍처는 폰 노이만 병목현상을 개선하기 위해 명령어와 데이터 메모리가 분리되어 취급된다.
    - 명령어, 데이터 메모리의 시스템 버스가 각각 존재하고, RISC의 명령어 구조를 따른다.
    - 명령어와 데이터 메모리가 분리되어 있기 때문에 명령어와 데이터가 다른 비트 수 기반을 가질 수 있다.
- 장점:
  - 폰 노이만 아키텍처는 프로그램 내장 방식을 적용했기 때문에 하드웨어를 재설정할 필요가 없이 소프트웨어만 교체하면 되므로 범용성이 크게 향상된다.
  - 공용 시스템 버스와 메모리를 사용하기 때문에 설계가 단순하고, 비용이 저렴하다.
  
  - 하버드 아키텍처는 명령어를 읽는 동시에 데이터를 읽거나 쓸 수 있어 성능이 우수하다.
  - 폰 노이만 병목현상이 적어 명령의 처리를 끝내자마자 다음의 명령을 읽어들일 수 있기 때문에 더 빠른 속도를 낼 수 있다.
  
- 단점:
  - 폰 노이만 아키텍처는 한 번에 하나의 명령어만 처리해서 CPU를 효율적으로 사용할 수 없다.
  - CPU와 메모리의 속도 차이로 인해 병목 현상이 발생하게 되어 성능 저하를 유발할 수 있다.
 
  - 하버드 아키텍처는 버스 시스템이 복잡하고, 설계가 어렵다.
  - 메모리와 데이터 메모리의 비트 수가 다를 경우 주소를 변경하는 과정을 거쳐야 한다.

#### 컴퓨터 설계의 기본 원리 (Fundamental Principles of Computer Design)
- 특징:
  1. 성능: 시스템의 처리 속도와 효율성을 높이기 위한 설계 원칙이다. 이를 위해 파이프라이닝, 캐시 메모리, 병렬 처리 등의 기술을 활용한다.

  2. 비용(Cost): 경제적인 설계를 목표로 하며, 자원과 비용을 최적화하여 효율적인 시스템을 구축하는 것을 의미한다. 불필요한 기능이나 자원 낭비를 최소화한다.

  3. 신뢰성(Reliability): 시스템이 오류 없이 안정적으로 작동할 수 있도록 설계한다. 오류 검출 및 수정 메커니즘을 포함하여 시스템의 신뢰성을 높인다.

  4. 유연성(Flexibility): 시스템이 다양한 요구와 환경 변화에 적응할 수 있도록 설계한다. 이를 통해 하드웨어와 소프트웨어의 업그레이드가 용이하도록 한다.

  5. 확장성(Scalability): 시스템이 성장하거나 변화하는 요구에 따라 쉽게 확장될 수 있도록 설계한다. 추가적인 하드웨어나 소프트웨어를 쉽게 통합할 수 있는 구조이다.

  6. 모듈화(Modularity): 시스템을 독립적인 모듈로 나누어 설계하여 복잡성을 줄이고 유지보수를 용이하게 한다. 각 모듈은 특정 기능을 담당한다.

  7. 추상화(Abstraction): 복잡한 시스템을 단순화하여 핵심 개념만을 다루는 원리이다. 하드웨어와 소프트웨어 간의 인터페이스를 정의하여 사용자가 시스템을 쉽게 이해하고 사용할 수 있도록 한다.

  8. 계층 구조(Hierarchy):시스템을 여러 계층으로 나누어 각 계층이 특정 기능을 담당하게 하여 복잡성을 관리한다. 예를 들어, 하드웨어, 운영체제 및 응용 프로그램 계층으로 구분한다.

## 명령어 집합 구조(ISA, Instruction Set Architecture)
- 정의: 
  - CPU가 이해할 수 있는 명령어들의 모음
#### CISC (Complex Instruction Set Computer)
- 정의: 복잡한 명령어 집합을 가진 컴퓨터 아키텍처로, 여러 가지 작업을 수행할 수 있는 복잡한 명령어를 제공하도록 설계되었다.
- 특징:
  - 가변 길이의 명령어를 사용한다.
  - 적은 수의 명령어로도 프로그램을 작성할 수 있다.
- 장점:
  - 적은 수의 명령어를 사용하므로, 메모리 공간을 절약할 수 있다.
- 단점:
  - 명령어의 크기와 프로그램이 실행되기까지의 시간이 일정하지 않다.
  - 하나의 명령어를 실행하는 데에 여러 클럭 주기를 필요로 한다.
  - 명령어 파이프라인을 구현하는 데 어려움이 있다.
- 예시:
  - x86, x86-64
#### RISC (Reduced Instruction Set Computer)
- 정의: 간단하고 효율적인 명령어 집합을 가진 컴퓨터 아키텍처로, 대부분의 명령어가 단순하고 빠르게 실행될 수 있도록 설계되었다.
- 특징:
  - 고정 크기의 명령어를 사용한다.
  - 메모리에 직접 접근하는 명령어를 load, store로 제한하여, 메모리 접근을 단순화하고 최소화를 추구한다.
  - 레지스터를 이용한 연산이 많다.   
- 장점:
  - 명령어 파이프라인을 구현하기 쉽다.
  - 간단한 명령어 처리로 전력 소모가 적다.
- 단점:
  - 프로그램을 이루는 명령어의 수가 많다.
- 예시:
  - ARM

## 데이터 표현 및 연산 (Data Representation and Operations)

#### 수의 체계 (Number Systems)

##### 이진수(Binary), 8진수(Octal), 16진수(Hexadecimal) 표현
- 정의: 
  - 이진수(Binary): 0과 1만으로 모든 숫자를 표현하는 이진법으로 표현한 수.
  - 8진수(Octal): 0부터 7까지의 수로 모든 숫자를 표현하는 8진법으로 표현한 수.
  - 16진수(Hexadecimal) 0부터 9, A부터 F로 모든 숫자를 표현하는 16진법으로 표현한 수.
- 특징:
  - 이진수는 한 글자당 1비트, 8진수는 3비트, 16진수는 4비트가 필요하다.
  - 이진수 앞에는 0b를 표기하거나, 끝에 아래첨자(2)를 붙인다.
  - 16진수 앞에는 0x를 표기하거나, 끝에 아래첨자(16)을 붙인다.
  - 이진수의 음수는 그 수의 2의 보수로 표현한다. 모든 0과 1을 뒤집은 후, 1을 더해준다.
      ![image](/image/2complement.png)
      강민철. (2022). *혼자 공부하는 컴퓨터구조 + 운영체제* (p.59). 한빛미디어.

##### 체계 간 변환
- 16진수 -> 2진수
  - 16진수 각 자리의 수를 4비트의 이진수로 간주하여, 따로따로 4비트의 이진수로 변경 후 잇는다.
      ![image](/image/16to2.png)

      강민철. (2022). *혼자 공부하는 컴퓨터구조 + 운영체제* (p.62). 한빛미디어.
- 2진수 -> 16진수
  - 2진수의 4자리를 하나의 16진수로 간주하여, 뒤에서부터 4자리 씩 변환한다.
      ![image](/image/2to16.png)
      
      강민철. (2022). *혼자 공부하는 컴퓨터구조 + 운영체제* (p.63). 한빛미디어.

#### 정수와 실수 표현 (Integer and Floating-Point Representation)
- 정의: 
  - 정수(Integer): 숫자를 표현하기 위한 데이터 타입 중 하나로, 소수점 없는 숫자를 저장하고 처리한다.
  - 실수(Real Number): 소수점 이하의 값을 포함할 수 있는 숫자 집합으로, 정수, 유리수, 무리수를 모두 포함하는 확장된 수의 개념이다.
##### 고정소수점과 부동소수점
- 정의: 
  - 고정소수점(Fixed Point): 소수점의 위치가 고정되어 있는 숫자 표현 방식이다.
  - 부동소수점(Floating Point): 소수점 위치가 고정되어 있지 않고, 숫자의 크기에 따라 소수점 위치가 이동하는 표현 방식이다.
- 특징:
  - 고정 소수점은 정수 부분과 소수 부분의 비율이 일정하다.
  - 고정된 자리 수로 인해 특정 숫자를 정확하게 표현할 수 있다.
  - 표현할 수 있는 값의 범위가 제한적이다.
  - 부동 소수점은 매우 큰 수나 매우 작은 수를 표현할 수 있게 해준다.
  - 일반적으로 가수와 지수로 나누어 표현한다.
- 장점:
  - 고정 소수점은 연산 속도가 빠르고, 메모리 사용이 효율적이다.
  - 부동 소수점은 표현할 수 있는 수의 범위가 넓다.
- 단점:
  - 고정 소수점은 표현할 수 있는 숫자의 범위가 좁아서 큰 숫자나 소수를 표현하기 어렵다.
  - 부동 소수점은 연산 속도가 느리고, 메모리 사용량이 많을 수 있다.

##### IEEE 754 표준 (IEEE 754 Standard) - 표현, 정밀도, 반올림
- 정의: 
  - 컴퓨터에서 부동 소수점을 표현하고 계산하기 위한 국제 표준.
1. 표현(Expression): 부동 소수점 표현의 구성 요소.
    - 부호 비트
      - 1비트의 크기를 가지고, 실수의 부호를 결정한다.
    - 지수부(Exponent)
      - 지수를 나타낸다.
    - 가수부(Significand)
      - 유효 숫자를 나타낸다.
2. 정밀도(Precision): 부동 소수점 수가 표현할 수 있는 숫자의 정확도.
    - 단정밀도(Single Precision)
      - 실수를 32비트(4바이트)로 표현하며 부호 1비트, 지수부 8비트, 가수부 23비트로 구성
    - 배정밀도(Double Precision)
      - 실수를 64비트(8바이트)로 표현하며 부호 1비트, 지수부 11비트, 가수부 52비트로 구성

3. 반올림(Rounding): 부동 소수점 연산에서 발생할 수 있는 반올림을 다루기 위한 다양한 방법 정의.
    - 가장 가까운 짝수로 반올림 (Round to Nearest, Even)
      - 가장 가까운 값으로 반올림하며, 동일한 거리의 경우 짝수로 반올림한다.
    - 올림 (Round Up)
      - 항상 다음 큰 값으로 반올림한다.
    - 내림 (Round Down)
      - 항상 다음 작은 값으로 반올림한다.
    - 정확한 반올림 (Round Toward Zero)
      - 절대값이 더 작은 방향으로 반올림한다.
       

#### 데이터 연산 (Data Operations)
- 정의:
  - CPU의 ALU에서 수행되는 기본적인 데이터를 처리하는 기본적인 연산.
##### 산술 연산 (Arithmetic Operations)
- 정의: 
  - 숫자에 대한 기본적인 수학적 연산으로, 일반적으로 정수 및 부동 소수점 수에 대해 수행된다.
- 특징: 
  - 기본적인 사칙연산 덧셈, 뺄셈, 곱셈, 나눗셈을 수행한다.
  - 오버플로우, 언더플로우와 같은 문제를 처리하기 위한 추가적인 논리가 필요하다.
##### 논리 연산 (Logical Operations)
- 정의: 
  - 비트 단위로 수행되는 논리적 판단을 나타내며, 주로 불리언 값 또는 비트 패턴에 적용된다.
- 특징:
  - 기본적인 비트 연산인 AND, OR, NOT, XOR을 수행한다.
  - 조건문, 비트 마스크, 플래그 설정 등에 활용된다.
  - ALU는 데이터의 비교 및 제어를 가능하게 한다.
##### 시프트 연산 (Shift Operations)
- 정의: 
  - 비트의 위치를 왼쪽 또는 오른쪽으로 이동시키는 연산이다.
- 특징: 
  - 왼쪽 시프트, 오른쪽 시프트, 산술 시프트, 논리 시프트를 수행한다.
  - 곱셈 및 나눗셈을 효율적으로 수행할 수 있는 방법을 제공한다.
  - 비트 필드를 조작한거나 특정 비트 패턴을 추출하는 데 사용한다.

#### Signed vs. Unsigned 데이터
- 정의: 
  - 정수를 표현할 때 사용하는 방식으로, 정수에 부호가 존재하면 Signed, 존재하지 않으면 Unsigned라고 한다.
- 특징:
  - Signed 정수는 양수,음수를 모두 표현할 수 있고, 최상위 비트를 부호 비트로 사용한다.
  - 최상위 비트가 0이면 양수, 1이면 음수를 나타낸다.
  - N비트의 signed 정수는 -2^n ~ 2^n -1 까지의 수를 표현할 수 있다.
  - Unsigned 정수는 양수와 0만 표현할 수 있으므로, 모든 비트를 숫자 값으로 사용한다.
  - N비트의 Unsigned 정수는 0부터 2^n -1까지의 수를 표현할 수 있다.
  
## 중앙처리장치 (CPU, Central Processing Unit)
- 정의: 
  - 컴퓨터 시스템의 핵심 구성 요소로, 프로그램의 명령어를 해석하고 실행하는 역할을 한다.

#### CPU의 구조와 구성 요소 (CPU Architecture and Components)
![image](/image/cpu.png)
https://taegyunwoo.github.io/interview/CS_CPU
- 특징:
  - CPU는 산술 논리장치(ALU, Arithmetic Logic Unit), 제어 장치(CU, Control Unit), 레지스터(Register) 등으로 구성된다.
  - 명령어 사이클을 통해 순서대로 명령어를 처리한다.

##### 산술 논리 장치(ALU, Arithmetic Logic Unit)
- 정의: 
  - 산술 연산(덧셈, 뺄셈 등)과 논리 연산(AND, OR, NOT 등)을 수행한다.
- 기능:
  - 산술 연산: 덧셈, 뺄셈, 곱셈, 나눗셈 등의 기본적인 수학 연산 수행한다.
  - 논리 연산: AND, OR, NOT, XOR 등의 논리적 판단을 수행한다.
  - 비교 연산: 두 값을 비교하여 크기, 같음 등을 판단한다.
##### 레지스터 (Registers)
- 정의: 
  - CPU 내부의 고속 임시 저장소로, 데이터와 명령어를 빠르게 저장하고 접근할 수 있도록 한다.
- 기능:
  - 일반 레지스터: 산술 연산의 결과 및 데이터 저장에 사용한다.
  - 특수 레지스터: 현재 실행 중인 명령어(IR), 다음 실행할 명령어의 주소(PC), 스택의 최상단 주소(SP)를 저장한다.
##### 제어 유닛(Control Unit)
- 정의: 
  - CPU의 다른 구성 요소 간의 작업을 조정하고 명령어의 실행 순서를 제어한다.
- 기능:
  - 명령어 해석: 메모리에서 가져온 명령어를 해석하여 어떤 작업을 수행할 지 결정한다.
  - 제어 신호 생성: ALU, 레지스터, 메모리 등에 제어 신호를 전달한다.
  - 데이터 흐름 관리: 데이터가 CPU 내부에서 어떻게 흐를 지 조정한다.
#### 명령어 사이클 (Instruction Cycle)
- 정의: 
  - CPU가 프로그램의 명령어를 실행하는 과정.
##### 명령어 인출(Fetch), 해독(Decode), 실행(Execute), 메모리접근(Memory Access)
![image](/image/instruction-cycle.png)
https://www.javatpoint.com/instruction-cycle
1. 명령어 인출(Fetch)
   - 정의: 
     - CPU는 메모리에서 다음 실행할 명령어를 가져온다.
   - 기능:
     - PC에 저장된 주소를 사용하여 메모리에서 명령어를 읽어온다.
     - 읽어온 명령어는 명령어 레지스터(IR)에 저장된다.
     - PC는 다음 명령어의 주소로 업데이트된다.

2. 해독(Decode)
   - 정의: 
     - 가져온 명령어를 해석하여 어떤 작업을 수행할지 결정한다.
   - 기능:
     - CU(제어 장치)는 IR에 저장된 명령어를 분석하여 필요한 연산과 데이터를 식별한다.
     - 명령어에 포함된 오퍼랜드(operand)와 주소 모드를 결정한다.
3. 실행(Execute)
   - 정의: 
     - 해석된 명령어에 따라 실제 연산을 수행한다.
   - 기능:
     - ALU(산술 논리 장치)가 산술 연산이나 논리 연산을 수행한다.
     - 필요한 경우, 메모리에서 데이터를 읽거나 쓰는 작업이 이루어진다.
     - 연산의 결과는 레지스터 또는 메모리에 저장한다.
4. 메모리접근(Memory Access)
   - 정의: 
     -  연산 결과를 적절한 위치에 저장한다.
   - 기능:
     - ALU의 연산 결과가 레지스터나 메모리에 저장한다.
     - 결과를 사용하는 후속 명령어를 위해 데이터를 준비한다.

#### 메모리 접근 방식 (Memory Access Methods)

## 메모리 구조 (Memory Architecture)

#### 메모리 계층 구조 (Memory Hierarchy)
![image](/image/MemoryHierarchy.png)
https://www.cs.swarthmore.edu/~kwebb/cs31/f18/memhierarchy/mem_hierarchy.html

- 정의: 
  - 다양한 종류의 메모리를 속도와 용량, 비용에 따라 계층적으로 배열한 것
- 특징:
  - CPU와 메모리 간의 성능 차이를 최소화하고, 효율적인 데이터 처리를 위해 설계됨
1. 레지스터(Register)
    - CPU 내부에 위치한 가장 빠른 메모리로, CPU가 직접 접근할 수 있는 소량의 데이터 저장소
    - 매우 빠른 접근 속도를 가지고 용량이 작다.
2. 캐시 메모리(Cache Memory)
    - CPU 내부에 위치한 가장 빠른 메모리로, CPU가 직접 접근할 수 있는 소량의 데이터 저장소
    - 매우 빠른 접근 속도를 가지고 용량이 작다.
3. 주 메모리(Main Memory)
    - 주로 DRAM(Dynamic Random Access Memory)으로 구성되어 있으며, 프로그램과 데이터를 일시적으로 저장
    - 접근 속도는 캐시보다 느리고, 전원이 꺼지면 데이터가 사라진다.
4. 보조 저장 장치(Secondary Storage)
    - 데이터를 영구적으로 저장하는 장치로, HDD, SSD, Flash Disk 등이 있다.
    - 접근 속도가 느리고, 대용량 데이터를 저장할 수 있다.
    - 비휘발성 메모리로 전원이 꺼져도 데이터가 유지된다.
5. 원격 보조 저장장치(Remote Secondary Storage)
    - 클라우드 스토리지나 외부 저장 장치 등으로, 주로 데이터 백업이나 아카이빙에 사용된다.
    - 접근 속도가 가장 느리고, 일반적으로 인터넷을 통해 접근한다.
#### 캐시 메모리 (Cache Memory)
- 정의:
  - CPU 내부에 위치한 가장 빠른 메모리로, CPU가 직접 접근할 수 있는 소량의 데이터 저장소
- 특징:
  - 매우 빠른 접근 속도를 가지고 있고, 용량이 작다.
##### 직접 매핑(Direct Mapping)
- 정의:
  - 각 메모리 블록이 캐시의 특정 라인에만 매핑되는 방식이다.
- 특징:
  - 메인 메모리와 캐시를 똑같은 크기로 나누고, 순서대로 매핑하는 것을 말한다.
  - 구현이 간단하고 빠르다.
  - 메인 메모리와 캐시를 하나씩 매칭하므로, 공간 부족으로 인해 캐시 교체가 빈번하게 일어나 성능이 낮을 수 있다.
  - 캐시 미스가 높다.
##### 집합 연관(Set-Associative)
- 정의:
  - 각 메모리 블록이 여러 캐시 라인 중 하나에 매핑될 수 있는 방식이다.
- 특징:
  - 지정된 수의 캐시 라인에 블록이 저장된다.
  - 직접 매핑보다 충돌이 적어 캐시 적중률이 향상된다.
  - 캐시 적중률이 향상된다.
##### 완전 연관(Fully Associative)
- 정의:
  - 메모리 블록이 캐시의 모든 라인에 자유롭게 매핑될 수 있는 방식이다.
- 특징:
  - 메모리 주소가 저장될 수 있는 캐시 라인 중에서 빈 라인을 찾아 저장된다.
  - 캐시 적중률이 가장 높고, 모든 블록이 모든 라인에 저장될 수 있어서 충돌이 최소화된다.
  - 구현이 복잡하고 비용이 많이 든다.
##### 캐시 적중률(Cache Hit Rate)
- 정의:
  - 캐시에 요청된 데이터가 캐시에 존재할 확률을 나타내는 지표로 백분율로 나타낸다.
- 계산 방법:
![image](/image/cachehit.png)
  - Cache hits: 요청된 데이터가 캐시에 있을 때 발생한다.
  - Cache misses: 요청된 데이터가 캐시에 없어서 메인 메모리에서 가져와야 할 때 발생
- 특징:
  - 캐시의 성능을 평가하는 지표로 사용된다. 
  - 높은 적중률이 시스템 성능을 향상시키는 데 중요하다.
#### 가상 메모리 (Virtual Memory)
- 정의:
  - 컴퓨터 시스템에서 물리적 메모리의 한계를 극복하고, 더 큰 메모리 공간을 제공하기 위해 사용하는 기술이다.
- 특징:
  - 운영 체제가 프로세스에 가상 주소 공간을 할당하고, 이를 물리적 메모리와 매핑하여 프로그램이 실제로 사용할 수 있는 메모리 양을 확장한다.
  - 메인 메모리를 2차 저장장치의 캐시로서 사용하는 기술이다.
  - 여러 프로세스들이 효과적이고 안정적으로 메인 메모리를 공유할 수 있다.
  - 메인 메모리의 속도와 HDD의 용량 장점을 모두 이용한다.
  - 가상 주소와 물리적 주소를 매핑한다.
##### 페이징(Paging)
- 정의:
  - 컴퓨터가 메인 메모리에서 사용하기 위해 데이터를 저장하고 검색하는 메모리 관리 기법이다.
- 특징
  - 가상 메모리와 물리적 메모리의 주소를 매핑하는 기법
  - 가상 메모리의 페이지 번호와, 인덱스 번호 쌍으로 가상 주소를 표현.
  - Page Table이란 자료구조 형태로 관리된다.
- 주소 변환 방식:
![image](/image/paging.png)
    1. Page Number에 offset을 더한 것이 virtual address이다.
    2. virtual page number를 physical page number로 변경한다.
- 장점:
  - 물리적 메모리에 저장될 때, 주소가 연속되어 저장될 필요가 없어 공간을 효율적으로 사용할 수 있다.
- 단점:
  - 내부 단편화 문제가 발생할 수 있다. 

##### 세그멘테이션(Segmentation)
- 정의:
  - 가상 메모리를 서로 크기가 다른 논리적 단위로 분할한 것이다.
- 특징
  - 의미가 같지 않은 논리적 내용을 기준으로 프로그램을 분할해서 저장한다.
  - 각 분할마다 크기가 다르다.
  - Paging 기법과 같이 테이블을 이용하여 주소를 매핑한다.
- 장점:
  - 내부 단편화 문제가 해소된다.
  - 프로그램의 중요한 부분과 그렇지 않은 부분을 분리하여 저장할 수 있어 보호의 기능을 할 수 있다.
- 단점:
  - 외부 단편화 문제가 발생할 수 있다.
##### 페이지 교체 알고리즘
- 정의:
  - 가상 메모리 시스템에서 물리적 메모리의 페이지가 부족할 때, 어떤 페이지를 메모리에서 제거할지를 결정하는 방법이다.
- 특징:
  - 물리적 메모리에 있는 페이지를 디스크의 스왑 영역으로 보낸다.
  - 페이지 부재율을 최소화하는 것이 목적이다.
###### LRU (Least Recently Used)
- 정의:
  - 가장 오랫동안 사용되지 않은 페이지를 교체하는 방법이다.
- 특징:
  - 페이지가 참조될 때마다 시간을 리스트에 기록한다.
  - 많은 OS에서 채택하는 알고리즘이다.
- 동작 방식:
![image](/image/LRU.png) 
https://yclib.dkyobobook.co.kr/main.ink
    1. 카운터나 스택을 통해 참조 시간을 기록한다.
    2. 가장 오랫동안 참조되지 않은 페이지를 교체한다.
- 장점:
  - 페이지 교체 횟수가 높지만 효율적이다.
- 단점:
  - 프로세스가 메모리에 접근할 때마다 페이지 시간을 기록해야 하므로, 막대한 오버헤드가 발생한다.
###### FIFO (First In First Out)
- 정의:
  - 물리적 메모리에 가장 먼저 올라온 페이지를 교체하는 방법.
- 동작 방식:
![image](/image/fifo.png)
https://wookcode.tistory.com/184 
    1. 참조한 페이지 번호를 프레임에 저장
    2. 가장 오래 있었던 페이지를 교체한다.
- 단점:
  - Bealady's Anomaly
    - Page frame을 증가시켜도 page fault가 감소하지는 않거나 오히려 증가하는 경우.
###### 최적 교체(Optimal Replacement)
- 정의:
  - 가장 오랫동안 사용되지 않을 페이지를 교체하는 방법이다.
- 특징:
  - 가장 이상적이고 효율적인 방법이다.
- 동작 방식:
![image](/image/opt.png)
https://wookcode.tistory.com/184     
    1. 5번 째 프레임에서, 1의 쓰임이 가장 마지막임을 알고있기 때문에 미리 교체함.
- 장점:
  - 모든 방법 중에서 페이지 교체 수가 가장 적다.
  - 가장 낮은 페이지 폴트율
- 단점:
  - 실제 시스템에서는 구현이 불가능하다.
#### TLB (Translation Lookaside Buffer)
- 정의:
  - 가상 메모리 시스템에서 가상 주소를 물리적 주소로 변환하는 과정에서 성능을 향상시키기 위해 사용되는 캐시 메모리이다.
- 특징:
  - TLB는 페이지 테이블의 일부 정보를 캐시하여 주소 변환 속도를 높이는 역할을 한다.
- 동작 방식:
![image](/image/tlb.png)
https://wpaud16.tistory.com/286
    1. 최근에 발생한 가상 메모리와 물리 주소의 변환 테이블을 저장한다.
    2. CPU가 가상 주소로 메모리에 접근하려고 할 때, TLB에 우선 접근하여 물리 주소를 찾는다.
    3. TLB에 존재하면 바로 메모리에 접근하고, 존재하지 않으면 Page table에 접근
- 장점:
  - CPU가 Page table에 접근하는 빈도를 줄여 속도를 향상시킨다.
- 단점:
  - Context Switching 문제가 발생할 수 있다.

## 입출력 시스템 (I/O Systems)
- 정의:
  - 컴퓨터 시스템에서 데이터와 정보를 외부 장치와 상호작용하는 과정을 관리하는 구성 요소이다.
#### 입출력 장치와 동작 원리 (I/O Devices and Operations)
- 특징:
  - 입력 장치에는 키보드, 마우스, 마이크 등이 있다.
  - 출력 장치에는 모니터, 프린터, 스피커 등이 있다.
  - 저장 장치에는 SSD, HDD DVD-ROM이 있다.
  - I/O 장치는 Device Controller에 연결되어 System Bus를 통해 메모리와 데이터를 주고 받는다.
#### 입출력 제어 방식 (I/O Control Mechanisms)

##### 프로그램 제어(Programmed I/O)
- 정의:
  - CPU가 직접 I/O 장치와 상호작용하여 데이터를 전송하는 방식이다.
- 특징:
  - CPU가 I/O 장치의 상태를 확인하고, 데이터 전송을 수동으로 관리하는 방식이다.
  - Polling 방식이라고도 함.
- 동작 방식:
    1. CPU는 I/O device의 Busy bit를 수시로 확인한다.
    2. Busy bit이 0에서 1로 변경될 때, 장치와 상호작용을 한다.
- 장점:
  - 구현이 간단하고 이해하기 쉬움.
- 단점:
  - CPU 자원 소모가 크다.
  - I/O 장치가 대기 중일 때 CPU의 Idle time이 발생한다.
- 예시
  - CPU는 키보드의 키가 눌렸을 때까지 기다렸다가, 입력 시에 레지스터에 저장된 값을 읽어온다.

# //다시 작성

##### 인터럽트 방식(Interrupt-driven I/O)
- 정의:
  - I/O 장치가 작업이 완료되면 CPU에 신호(인터럽트)를 보내는 방식이다.
- 특징:
  - CPU가 I/O 장치의 상태를 확인하고, 데이터 전송을 수동으로 관리하는 방식이다.
- 동작 방식:
    1. CPU는 I/O 장치에 요청을 보내고, 장치가 작업을 완료할 때까지 다른 작업을 수행한다.
    2. 작업이 완료되면 I/O 장치는 인터럽트를 발생시키고, CPU는 이 신호를 수신하여 해당 I/O 작업을 처리한다.
- 장점:
  - CPU 자원을 효율적으로 사용할 수 있으며, 대기 시간을 줄일 수 있다.
  - I/O 장치가 작업을 완료할 때만 CPU가 개입하므로 효율적이다.
- 단점:
  - 인터럽트가 많이 발생하면, CPU가 인터럽트 처리에 많은 시간을 소모함.
##### DMA(Direct Memory Access)
- 정의:
  - I/O 장치가 CPU의 개입 없이 직접 메모리에 데이터를 전송하는 방식
- 특징:
  - DMA 컨트롤러가 I/O 장치와 메모리 간의 데이터 전송을 관리한다.
  - CPU는 DMA 작업을 시작한 후 다른 작업을 수행할 수 있으며, DMA가 작업을 완료하면 인터럽트를 발생시킨다.
- 동작 방식:
    1. DMA Controller가 I/O device와 메모리 간의 데이터 전송을 관리한다.
    2. CPU는 DMA 작업을 시작한 후 다른 작업을 수행하고, DMA는 작업을 완료하면 인터럽트를 발생시킨다.
- 장점:
  - CPU의 부담을 줄이고, 데이터 전송 속도를 높인다.
  - CPU가 I/O 작업을 기다리지 않아 효율성이 향상된다.
- 단점:
  - DMA 컨트롤러의 추가적인 하드웨어가 필요하다.
  - DMA가 메모리에 직접 접근하므로, 메모리 보호에 대한 보안 문제가 발생할 수 있다.
#### 인터럽트 (Interrupts)

#### I/O 버스와 데이터 전송 (I/O Bus and Data Transfer)
- 정의:
  - CPU와 여러 I/O 장치 간의 데이터 전송을 위한 물리적 경로이다.
- 특징:

  ![image](/image/bus.png)

  https://en.wikipedia.org/wiki/System_bus
  - Data Bus, Address Bus, Controll Bus로 구성되어있다.
  - Data Bus는 실제 데이터가 전송되는 경로로, 
  - Address Bus는 I/O 장치의 주소를 지정하는 데 사용하는 경로로, 
  - Control Bus는 데이터 전송을 제어하는 신호를 전달한다.

## 프로세서 설계 (Processor Design)

#### 데이터 경로 설계 (Datapath Design)
- 정의:
  - MIPS의 명령어를 처리하기 위한 경로
- 특징:
  - 명령어 처리 사이클에 따라서 설계한다.
##### 단일 사이클(Single-Cycle Design)
- 정의:
  - 모든 명령어 실행이 하나의 사이클(클럭) 내에서 완료되는 구조이다.
- 특징:
  ![image](/image/datapath.png)

  - Fetch, Decode, Execute, Memory Access, Write Back의 모든 단계를 수행한다.
  - 모든 구성 요소가 동일한 클럭 신호에 의해 동기화되어 작동한다.
- 장점:
  - 설계가 간단하여 이해하기 쉽고, 하드웨어 구현이 직관적이다.
  - 모든 명령어가 동일한 사이클 시간 내에 완료되므로 성능 예측이 쉽다.
- 단점:
  - 복잡한 명령어가 더 많은 시간이 소요되더라도 모든 명령어가 동일한 사이클을 소모하므로, 전체 성능이 저하된다.
  - 가장 느린 명령어에 맞춰 클럭 주파수를 설정해야 하므로, 성능이 제한된다.
##### 멀티 사이클(Multi-Cycle Design)
- 정의:
  - 명령어 실행을 여러 개의 사이클로 나누어 수행하는 구조이다.
- 특징:
  ![image](/image/datapath.png)

  - Fetch, Decode, Execute, Memory Access, Write Back의 각 단계는 별도의 클럭 사이클에서 따로 수행함.
  - 각 명령어는 여러 클럭 사이클을 통해 단계별로 처리된다.
  - ALU, 레지스터 파일, 메모리 등의 자원을 여러 사이클에 걸쳐 공유할 수 있다.
- 장점:
  - 설계가 간단하여 이해하기 쉽고, 하드웨어 구현이 직관적이다.
  - 모든 명령어가 동일한 사이클 시간 내에 완료되므로 성능 예측이 쉽다.
- 단점:
  - 구현이 복잡하다.
  - 사이클이 여러 개이므로, 전체 실행 시간이 증가한다.

#### 파이프라인 처리 (Pipelining)

##### 파이프라인의 개념과 이점
- 정의:
  - 각 명령어 실행 과정을 여러 단개로 나누어, 각 단계를 동시에 처리하는 기술.
- 특징:
  - 일반적으로 5단계로 나누어 명령어를 처리한다.
  - 독립적으로 각 단계를 수행하여 전체 성능을 향상시킨다.

- 구성 요소:
  ![image](/image/pipeline.png)

  1. Instruction Fetch(IF)
    - 메모리에서 가져온 명령어를 가져온다.
  2. Instruction Decode(ID)
    - 가져온 명령어를 해석하고 필요한 operand를 읽는다.
  3. Execution(EX)
    - ALU를 사용하여 명령어를 실행한다.
  4. Memory Access(MEM)
    - 메모리에 접근하여 데이터를 읽거나 쓴다.
  5. Write Back(WB) 
    - ALU의 결과를 레지스터에 저장한다.  
  - 장점:
    - 여러 명령어가 동시에 처리되므로, 처리량 증가
    - CPU의 자원을 효율적으로 사용한다.
  - 단점:
    - 파이프라인 연산 도중에 문제가 생기면 전체 연산과정에 문제가 발생한다.
    - 서로 단계 별 다른 메모리 주소를 이용하여 연산을 한다.
##### 위험 요소(Hazards)
- 정의:
  - 파이프라인을 처리하면서 발생할 수 있는 3가지의 위험.
- 특징:
  - 모든 위험은 Stall(Waiting)으로 해결할 수 있다.
1. Data Hazard
   - 정의:
     - 한 명령어가 다른 명령어의 결과에 의존할 때 발생하는 위험.
   - 예시:
     ![image](/image/dataHazard.png)
     https://jesus-never-fail.tistory.com/13
     - ADD 연산에서 $1에 결과를 저장하기도 전에, SUB에서 $1에 접근한다.
   - 해결 방안:
     - Freezing the pipeline
       - 앞의 명령어가 데이터를 write 할 때까지, register update를 중지시킨다.
     - Forwarding
       - Write 하기 전에, 계산이 완료되면 다음 명령어로 결과를 전달한다.
2. Control Hazard
   - 정의:
     - 분기 명령어가 발생했을 때, 다음에 어떤 명령어를 가져와야 할지를 결정하기 어려운 상황에 대한 위험.
   - 예시:
     - Pipeline을 통해 다음 명령어를 수행해야 하는 데, jmp를 해서 다음 명령어를 수행할 수 없다.
   - 해결 방안:
     - 분기 예측(Branch Prediction):
       - branch 예측한 후 성공하면 그대로 실행, 실패 시에는 flush한 후 target 명령어를 넣는다.
3. Structual Hazard
   - 정의:
     -  파이프라인 단계에서 동일한 하드웨어 자원(예: ALU, 메모리 등)을 여러 명령어가 동시에 사용하려고 할 때 발생하는 위험.
   - 예시:
     - 서로 다른 두 명령어가 fetch를 위해 memory에 접근하려는 경우
   - 해결 방안:
     - 사용 가능한 하드웨어의 수를 늘린다.
## 성능 평가와 최적화 (Performance Evaluation and Optimization)

#### 성능 측정 지표 (Performance Metrics)
- 정의:
  - 성능이란 실행 시간의 역수로 정의한다.
##### 처리량(Throughput), 응답 시간(Response Time), 클럭 주기(Clock Cycle)
- 정의:
  - 처리량(Throughput): 단위 시간 당 컴퓨터가 수행하는 작업량
  - 응답 시간(Response Time): 컴퓨터가 한 작업을 수행하는 데 걸리는 시간
  - 클럭 주기(Clock Cycle): 한 클럭에 걸리는 시간. ps 단위로 나타냄.
- 특징:
  - 처리양을 통해 시스템의 효율성과 성능을 평가한다.
  - 클럭 속도가 높을 수록 클럭 주기가 짧아지고, CPU가 더 많은 명령어를 처리할 수 있다.
  - CPU Time은 CPU가 특정 작업을 수행하는 데 소요되는 시간을 뜻하고, Clock Cycle에 Clock Cycle Time을 곱한 값이다.
  ![image](/image/cputime1.png)
  https://perfect-occasion.co.kr/entry/%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%A0%84%EB%B0%98%EC%A0%81%EC%9D%B8-%EC%86%8C%EA%B0%9C-3-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81-%EA%B8%B0%EB%B2%95-CPU-%EC%8B%9C%EA%B0%84-%ED%81%B4%EB%9F%AD-%EC%86%8D%EB%8F%84-CPI-%EB%AA%85%EB%A0%B9%EC%96%B4-%EC%88%98-%EC%B5%9C%EC%A0%81%ED%99%94

#### Amdahl의 법칙 (Amdahl's Law)
![image](/image/amdahl.png)
https://ko.wikipedia.org/wiki/%EC%95%94%EB%8B%AC%EC%9D%98_%EB%B2%95%EC%B9%99
- 정의:
  - 병렬 컴퓨팅에서 성능 향상의 한계를 설명하는 원리로, 특정 작업에서 병렬화할 수 있는 부분과 병렬화할 수 없는 부분의 비율에 따라 전체 성능 향상이 어떻게 제한되는지를 나타낸다.
- 특징:
  ![image](/image/amdahl-equation.png)
  - S는 전체 시스템의 성능 향상 비율이다.
  - P는 병렬화 가능한 작업의 비율이다 (0과 1 사이의 값).
  - N은 병렬로 수행할 수 있는 프로세서의 수다.
  - (1 - P)는 직렬로 실행해야 하는 작업의 비율이다.

#### 시스템 성능 최적화 (System Performance Optimization)

##### 캐시 최적화(Cache Optimization)
- 정의:
  - 캐시 메모리의 성능을 극대화하기 위한 기술
- 주요 기법:
1. 캐시 크기 최적화
   - L1, L2, L3로 여러 단계의 캐시를 사용하여 데이터 접근을 최적화한다.
   - L1은 가장 빠르고, L3는 가장 큰 용량을 가진다.
2. 캐시 라인 크기 최적화
   - 캐시에서 데이터를 저장하는 기본 단위인 캐시 라인의 크기를 최적화한다.
   - 데이터 구조의 접근 패턴에 맞춰 배열이나 행렬을 설계한다.
3. 프리페칭(Prefetching)
   - CPU가 데이터 접근 패턴을 예측하여 미리 데이터를 캐시로 가져오는 것이다.
   - 데이터가 필요한 시점에 이미 캐시에 존재하게 되어 성능이 향상된다.

##### 분기 예측(Branch Prediction)
- 정의:
  -  조건문이나 분기 명령어의 결과를 미리 예측하여 파이프라인의 흐름을 최적화하는 방법이다.
- 특징:
  - 프로그램에서 조건문이나 반복문이 많이 사용되는 만큼, CPU가 다음 명령어의 결과를 예측하여 파이프라인을 채우는 것이 중요하다.
- 주요 기법:
1. 고정 예측
   - 특정 규칙에 따라 분기를 예측하는 방법
   - Always Taken: 모든 분기를 참으로 예측한다.
   - Always Not Taken: 모든 분기를 거짓으로 예측한다.
   - Profile-Guided: 프로그램 실행 전에 분석된 데이터를 기반으로 예측한다.

2. 동적 예측
   - 실행 중에 분기 결과를 기반으로 예측하는 방법
   - 히스토리 기반 예측: 이전 분기 결과를 기록하여 다음 분기를 예측
   - 패턴 기록기: 최근의 분기 결과를 기록하여 유사한 패턴을 기반으로 예측
   - 지점 예측기: 특정 분기 지점에 대한 예측 정보를 저장.
