# Operation System

## 운영체제 개요

#### 운영체제의 역할과 목적
- 정의: 
  - 프로그램에 필요한 자원을 할당하고, 프로그램이 올바르게 실행되도록 돕는 특별한 소프트웨어.
- 역할:
  - 자원 관리
  - 프로세스 관리
  - 메모리 관리
  - 파일 시스템 관리
  - 사용자 인터페이스 제공
  - I/O 장치 관리
- 목적:
  - 유저 프로그램의 실행 및 문제 해결
  - 효율적인 방법으로 하드웨어 사용
  - 컴퓨터 시스템의 편리한 이용

#### 운영체제의 구조 (Structure of Operating Systems)
![image](/image/os_structure.png)
- 특징:
  - 크게 User interface, System call, service 부분으로 나뉜다.
  - User interface 부분은 GUI, batch 파일, Shell이 포함된다.
  - System call 부분은 Kernel mode로 작동하는 명령어를 수행하는 부분이다.
  - Service 부분은 프로그램 개발 및 실행에 편리한 환경을 제공한다.
  - Kernel Mode와 User Mode로 나뉘어 응용 프로그램이 시스템에 무분별하게 접근하는 것을 막고, 하드웨어를 보호한다.
##### 커널(Kernel)
- 정의:
  - 운영체제 중 항상 메모리에 올라가 있는 운영체제의 핵심 부분으로써 하드웨어와 응용 프로그램 사이에서 인터페이스를 제공하고, 컴퓨터 자원을 관리하는 역할을 한다.
- 특징:
  - 사용자와 직접적으로 상호작용은 하지 않고, Shell 이라는 명령어 해석기를 통해 상호작용한다.
  - System call을 통해 응용 프로그램이 커널에 접근할 수 있도록 한다.
- 주요 기능:
  - 프로세스 관리
  - 메모리 관리
  - 장치 관리
  - 파일 시스템 관리
##### 사용자 모드(User Mode) vs 커널 모드(Kernel Mode)
1. 사용자 모드(User Mode)
- 정의:
  - 응용 프로그램의 코드가 실행되고, 커널의 특권 명령어를 제외한 일반 명령어를 수행할 수 있는 모드.
- 특징:
  - 시스템 데이터에 제한된 접근만이 허용되고, 하드웨어에 직접적인 접근이 불가능하다.
  ![image](/image/systemcall.png)
  Operating System Concepts
  - 사용자 모드로 실행되는 프로그램이 커널의 명령어에 접근하려면, System call을 요청하여 커널 모드로 전환한 후 수행한다.
  - mode bit를 이용하여 0일 때 Kernel, 1일 때, user process임을 나타낸다.
  
2. 커널 모드(Kernel Mode)
- 정의:
  - 커널의 코드가 실행되고, 커널의 특권 명령어를 포함한 모든 명령어를 수행할 수 있는 모드.
- 특징:
  - 운영체제를 위한 동작을 담당한다.
  - 시스템의 모든 메모리에 접근할 수 있고, 모든 CPU 명령을 실행할 수 있다.
  - 운영체제 코드나 디바이스 드라이버 같은 커널모드 코드를 실행한다.
#### 운영체제의 종류 (Types of Operating Systems)
1. 데스크톱 운영 체제
  - Windows, macOS, Linux 등..
2. 서버 운영 체제
  - Windows Server, Linux Server, Unix 등..
3. 모바일 운영 체제
  - Android, iOS 등..
4. 클라우드 운영 체제
  - OpenStack, VMware vSphere 등..

##### 단일 사용자/다중 사용자(Single-user/Multitasking)
1. 단일 사용자(Single-user)
  - 정의:
    - 한 번에 한 명의 사용자만 사용 가능한 운영체제이다.
  - 특징:
    - 한 명의 사용자만 지원한다.
    - 다중 사용자 시스템보다 구조가 단순하다.
    - 주로 개인용 PC나 모바일 기기에서 사용된다.
  - 예시:
    - macOS, Windows, MS-DOS
2. 다중 사용자(Multitasking)
  - 정의:
    - 여러 사용자가 동시에 시스템 자원을 공유하고 사용할 수 있는 운영체제이다.
  - 특징:
    - 여러 사용자가 같은 시스템을 동시에 접속 및 사용 가능하다.
    - 각 사용자에게 독립된 계정과 파일 시스템 제공한다.
    - 주로 서버 및 메인프레임에서 사용한다.
  - 예시:
    - Unix, Linux, Windows Server
##### 단일 작업/다중 작업(Single-tasking/Multitasking)
1. 단일 작업(Single-tasking)
  - 정의:
    - 한 번에 하나의 작업만 처리할 수 있는 운영체제이다.
  - 특징:
    - 시스템이 동시에 단 하나의 프로세스만 실행 가능하다.
    - 운영체제의 설계 및 구현이 비교적 단순하다.
  - 예시:
    - MS-DOS
2. 다중 작업(Multitasking)
  - 정의:
    - 여러 작업을 동시에 실행할 수 있는 운영체제이다.
  - 특징:
    - 운영체제가 작업 간에 CPU를 강제 전환하는 선점형 멀티태스킹과, 작업이 스스로 CPU를 양보하는 비선점형 멀티태스킹으로 나뉜다.
    - 대부분의 현대 운영체제가 다중 작업을 지원한다.
  - 예시:
    - Windows, macOS, Linux, Android, iOS
##### 분산 OS(Distributed Operating Systems)
- 정의: 
  - 분산 운영체제는 여러 독립적인 컴퓨터(노드)가 네트워크를 통해 연결되어 마치 하나의 시스템처럼 동작하도록 설계된 운영체제이다.
- 특징:
  - 여러 컴퓨터의 자원을 공유하여 효율적으로 사용할 수 있다.
  - 사용자에게는 분산된 시스템이 하나의 시스템처럼 보인다.
  - 시스템의 성능을 높이기 위해 더 많은 노드를 쉽게 추가할 수 있다.
- 예시:
  - GCP, Amazon AWS
##### 실시간 OS(Real-Time Operating Systems)
- 정의: 
  - 특정 작업을 정해진 시간 내에 반드시 수행해야 하는 요구사항을 가진 운영체제이다.
- 특징:
  - 작업의 완료 시간이 중요하며, 시간에 대한 예측 가능성이 필요하다.
  - 중요한 작업이 신속하게 처리될 수 있도록 우선순위를 설정한다.
  - 외부 이벤트에 대한 빠른 응답이 필수적이다.
- 예시:
  - VxWorks, QNX
## 프로세스 관리 (Process Management)//ch3

#### 프로세스와 스레드 (Processes and Threads)
1. 프로세스(Process)
- 정의:
  - 실행 중인 프로그램을 의미하며, 메모리에서 프로그램의 코드, 데이터, 스택 등을 포함하는 독립적인 실행 단위이다.
- 특징:
  - 프로세스는 서로 독립적이며, 각 프로세스는 자신의 메모리 공간을 가진다.
  - 운영체제는 각 프로세스에 필요한 자원을 할당하고 관리한다.
  - 프로세스는 생성, 준비, 실행, 대기, 종료 등의 상태를 가질 수 있다.
  - 프로세스 간의 전환(컨텍스트 스위칭)은 상대적으로 비용이 많이 든다.
2. 스레드(Thread)
- 정의:
  - 프로세스 내에서 실행되는 경량의 실행 단위로, 프로세스의 자원을 공유하면서 독립적으로 실행되는 단위이다.
- 특징:
  - 같은 프로세스 내의 스레드는 메모리 공간(코드, 데이터 등)을 공유한다.
  - 스레드는 프로세스보다 더 적은 자원으로 생성되고 관리된다.
  - 스레드 간의 전환은 프로세스 간의 전환보다 빠르다.
  - 여러 스레드를 사용하여 동시에 작업을 수행할 수 있어 효율적인 프로그램 실행이 가능하다.

##### 프로세스 상태(Process States) - 생성(New), 준비(Ready), 실행(Running), 대기(Waiting), 종료(Terminated)
![image](/image/Process_state.png)
1. 생성(New)
- 정의:
  - 프로세스가 생성되었지만 아직 실행되지 않은 상태이다.
- 특징:
  - 프로세스의 메모리 공간이 할당되고 초기화 작업이 이루어진다.
  - 프로세스가 생성되고, 준비 단계로 전이한다. 

2. 준비(Ready)
- 정의:
  - 프로세스가 CPU를 할당받기 위해 대기 중인 상태이다.
- 특징:
  - 프로세스가 실행될 준비가 되어 있지만, CPU를 사용할 수 없는 상황이다.
  - CPU가 프로세스에 할당되고, 실행 상태로 전이한다.

3. 실행(Running)
- 정의:
  - CPU가 프로세스에 할당되어 실제로 명령어가 실행되고 있는 상태이다.
- 특징:
  - 프로세스가 이 상태에서 작업을 수행한다.
  - 프로세스의 실행이 완료되면, 종료 상태로 전이한다.
  - 프로세스가 타이머에 의해 interrupt를 받으면, 준비 상태로 전이된다.
  - 프로세스에 I/O 처리가 필요하면, 프로세스는 대기 상태로 전이한다.

4. 대기(Waiting)
- 정의:
  - 프로세스가 I/O 작업이나 다른 이벤트를 기다리고 있는 상태이다.
- 특징:
  - 파일 읽기나 네트워크 응답을 기다리는 동안 이 상태에 놓인다.
  - I/O 처리가 완료되면 다시 준비 상태로 전이된다.

5. 종료(Terminated)
- 정의:
  - 프로세스의 실행이 완료되어 종료된 상태이다.
- 특징:
  - 프로세스가 사용하던 자원이 해제되고, 프로세스에 대한 모든 정보가 운영체제에 의해 정리된다.

##### 스레드(Thread) - 멀티스레딩(Multithreading)의 개념과 장점
- 정의:
  - 한 프로세스가 여러 스레드로 동시에 여러 작업을 수행하는 것이다.
- 특징:
  - 한 프로세스 내의 스레드는 메모리와 자원을 공유하므로, 데이터 전송이 빠르고 효율적이다.
  - 여러 스레드가 동시에 실행될 수 있어, 병렬 처리가 가능하다.
  - 스레드는 운영체제의 스케쥴러에 의해 관리되므로, 실행 순서가 예측 불가능할 수 있다.
  - 하나의 스레드가 작업을 할 때, 다른 스레드가 별도의 작업을 할 수 있다. 

- 장점:
  - 프로세스에 비해 스레드가 가벼워, 생성 및 종료가 빠르다.
  - 한 프로세스 내의 스레드들은 메모리를 공유하기 때문에 내장된 데이터의 용량이 작다.
  - 프로세스에 비해 Context Switching 비용이 낮고, 반응 속도가 빠르다.

#### CPU 스케줄링 (CPU Scheduling)
![image](/image/Process_state.png)
##### 선점형 스케줄링 (Preemptive Scheduling)
- 정의:
  - 실행 중인 프로세스가 CPU를 점유하고 있을 때, 운영 체제가 다른 프로세스에 CPU 자원을 할당하기 위해 현재 프로세스를 강제로 중단할 수 있는 방식이다.
- 특징:
  - 운영 체제가 특정 조건(예: 높은 우선 순위의 프로세스가 대기 중일 때)에서 현재 실행 중인 프로세스를 중단하고 다른 프로세스에 CPU를 할당할 수 있다.
  - Context Switch로 인한 오버헤드가 발생한다.
  - running -> ready 상태에서의 interrupt, waiting -> ready인 상태에서 I/O interrupt, System call에서 발생한다.
  - 실시간 응답환경, 데드라인 응답환경 등 우선순위가 높은 프로세스를 먼저 처리해야하는 경우에 유용하다.
1. Round Robin
- 정의:
  -  프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간단위(Time Quantum/Slice)로 CPU를 할당하는 방식의 알고리즘이다.
- 특징:
  - 단위 시간동안 수행한 프로세스는 ready queue의 맨 뒤로 이동하고, context switch가 일어난다.
![image](/image/roundrobin.png)
  - Quantum이 4인 Round Robin이다.
  - 모든 프로세스는 4만큼씩만 순서대로 실행된다.
- 예시:
  - 사용자와의 상호작용이 많은 시스템에서, 응답 시간을 최소화해야 할 때.
  - 여러 프로세스가 동시에 실행되고, 각 프로세스의 실행 시간이 다를 때.

2. Priority Scheduling
- 정의:
  - 프로세스를 우선 순위에 따라서 순서대로 처리하는 알고리즘이다.
- 특징:
  - 프로세스가 ready queue에 도착하면, 도착한 프로세스의 우선순위와, 현재 실행중인 프로세스의 우선순위를 비교하여 우선순위가 높은 프로세스를 먼저 처리하는 방식.
  - 우선순위가 같을 경우 FCFS를 적용한다.
  ![image](/image/priority_scheduling.png)
  - 프로세스의 우선순위대로 p2, p5, p1, p3, p4 순서대로 처리한다.
- 예시:
  - 프로세스의 중요도가 명확하게 구분될 때
  - 긴급한 프로세스가 생길 경우

3. Multilevel Feedback Queue
- 정의:
  - 프로세스를 목적에 맞게 여러 개의 큐로 나누고, 각 큐마다 다른 스케줄링 알고리즘을 적용하는 알고리즘이다.
- 특징
  - 프로세스를 최상위 큐부터 삽입하여, CPU시간을 많이 소비하면 다음 큐로 점점 내려보낸다.
  - Starvation 문제가 발생할 수 있다.
  - 낮은 우선 순위의 큐에서 오래 대기하는 프로세스를 높은 우선순위의 큐로 이동시키는 Aging 기법으로 Starvation을 해결한다.
![image](/image/multiqueue.png)
  - 실시간 프로세스, 시스템 프로세스 등의 우선순위가 높고, 배치 프로세스의 우선순위는 낮다.
  - 우선 순위가 높은 큐에는 RR을 적용하고, 우선 순위가 낮은 큐에는 FCFS를 적용한다.
- 예시:
  - 프로세스의 유형이 다양할 때
  - 프로세스 별로 요구 유형이 있을 때

##### 비선점형 스케줄링 (Non-preemptive Scheduling) 
- 정의:
  - 한 프로세스가 CPU를 할당받으면 작업 종료 후 CPU 반환 시까지 다른 프로세스는 CPU 점유가 불가능한 스케줄링 방식이다.
- 특징:
  - 스케줄러 호출에 따른 Context Switching의 오버헤드가 적다.
  - 하나의 프로세스가 대기시간이 짧은 프로세스들을 대기시켜, 처리율이 떨어질 수 있다. 
  - 일괄 처리 시스템에 적합하다.

1. FCFS (First-Come-First-Served)
- 정의:
  - 먼저 도착한 프로세스부터 처리하는 알고리즘이다.
- 특징
  - 구현이 간단하다
  - 평균 대기시간이 증가한다.
  - starvation이 발생하지 않는다.
  - 프로세스의 실행 시간이 불균형한 경우, 전체 시스템의 성능이 저하될 수 있다.
![image](/image/fcfs_scheduling.png)
  - p1, p2 p3 순서대로 큐에 도착했다.
  - 도착 순서대로 프로세스를 처리한다.
- 예시:
  - 모든 프로세스의 처리 시간이 비슷한 경우
  - 단순한 시스템

2. SJF (Shortest Job First)
- 정의:
  - 대기하는 작업 중에서 실행 시간이 가장 짧은 프로세스부터 처리하는 스케줄링 방식이다.
- 특징:
  - CPU Burst time을 미리 알기 어렵기 때문에 현실적으로 알고리즘을 사용하기 어렵다.
![image](/image/sjf.png)
  - Burst time이 낮은 순서대로 p4, p1, p3, p2 순서대로 일을 처리한다.


3. Priority Scheduling
- 정의:
  - 프로세스를 우선 순위에 따라서 순서대로 처리하는 알고리즘이다.
- 특징:
  - 실행중인 프로세스가 없을 때, 가장 우선순위가 높은 프로세스부터 수행하는 알고리즘이다.
  - 선점형 priority Scheduling과 다르게 진행중인 프로세스가 끝날 때 까지 기다린다.

##### 스케줄링 성능 평가 (응답 시간, 대기 시간, 처리량 등)

#### 동기화 (Synchronization)//ch3, ch6 ch 7
- 정의:
  - 여러 프로세스가 공유하는 자원의 일관성을 유지하는 것.
- 특징:
  - 여러 프로세스가 공유 자원을 사용하는 과정에서 race condition 문제가 발생할 수 있어, 공유 자원의 신뢰성이 떨어질 수 있다.
  - race condition이란 여러 프로세스나 스레드가 동시에 공유 자원에 접근할 때, 접근 순서에 따라 실행 결과가 달라지는 것이다.
  - 
##### 임계 구역 문제 (Critical Section Problem)
- 정의:
  - 공유 자원에 대한 접근 순서에 따라 실행 결과가 달라지는 프로그램의 코드 영역
- 특징:
  - 임계 구역에 동시에 접근할 수 있는 프로세스는 오직 하나만 존재해야 한다. 다른 프로세스는 대기해야 한다.
  - 임계 구역에 진입하려는 프로세스가 있을 때, 그 중에서 어떤 프로세스가 임계 구역에 진입할 수 있는지는 시스템의 상태에 따라 결정되어야 한다.
  - 임계 구역에 진입하기 위해 대기하는 프로세스는 유한한 시간 안에 반드시 임계 구역에 진입할 수 있어야 한다.
  - 임계 구역은 여러 프로세스가 공유하는 자원에 접근하는 구역으로, 자원의 일관성과 무결성을 유지하기 위해 필요한 제한을 설정한다.
- 구조:
![image](/image/critical%20section.png)
  - Entry section : 각 프로세스가 임계구역(critical section)에 들어가기 위해 진입허가 요청을 하는 코드가 있는 부분
  - critical section : 한 프로세스가 자신의 임계구역에서 작업을 수행하는 동안에는 다른 프로세스는 그들의 임계구역에 접근할수 없다
  - exit section : 임계구역을 빠져나오는 코드가 있는 부분
  - remainder section: 나머지 부분

##### 세마포어(Semaphore)와 모니터(Monitor)
1. 세마포어(Semaphore)
- 정의:
  - 프로세스 간의 동기화 및 상호 배제를 위해 사용되는 동기화 도구이다.
- 특징:
  - 세마포어는 카운터 값을 유지하며, 이를 통해 여러 프로세스가 공유 자원에 접근할 때 발생할 수 있는 문제를 해결한다.
  - p라고 부르는 wait(), v라고 부르는  signal() 함수로 구성된다.
  - Semaphore S값을 통해 공유 자원에 접근할 수 있는 프로세스/스레드의 수를 설정한다.
  - Mutex와 다르게 여러 개의 프로세스가 접근 가능하도록 한다.
- 동작 방식:
![image](/image/semaphore.png)
  - wait()함수에서는 critical section에 들어가기 전에 수행하는 함수로, S값을 하나 감소 시킨 후, 자원에 접근한다.
  - S가 0이라면, S>=1이 될 때까지 기다린다.
  - signal()함수는 임계 구역에서 나올 때 수행하는 함수로, 자원을 반납하여 S값을 하나 증가시킨다.
  
2. 모니터(Monitor)
- 정의:
  - 프로세스로 하여금 세마포어의 시그널 메커니즘을 자동으로 처리하는 것 + 편리하게 뮤텍스 개념을 사용할수 있도록 프로그래밍 언어, 혹은 프레임워크 차원에서 제공하는 기법이다.
- 특징:
  - 모니터는 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스(프로시저)만을 제공한다.
  - 공유 자원에 접근하고자 하는 프로세스는 모니터에 "작업"을 요청하면 된다.
  - 모니터는 작업을 큐에 저장하고 순서대로 처리하면서 결과만 프로세스에 알려준다.
  - 한 번에 하나의 프로시저만 접근하여 사용 가능하며 wait(), signal() 함수를 사용한다.
  - 주로 객체지향 언에에서 사용한다.
- 예시:
  - 객체와 synchronized 블럭에 의해 동기화되는 모든 객체에 고유한 모니터가 결합이 되어 동기화 작업을 수행하게 된다.


##### 뮤텍스(Mutex)와 조건 변수(Condition Variables)
- 정의:
  - 임계 구역에 하나의 작업 스레드만 접근할 수 있도록 허용하는 것이다.
- 특징:
  - 세마포어와는 다르게 하나의 스레드만 접근을 허용한다.
  - 전역 변수인 lock을 소유해야 임계 영역에 들어갈 수 있는 조건이 있다.
  - 작업이 끝나면 lock을 반환한다.
  - busy waiting 방식으로 lock의 현황을 지속적으로 확인한다.
  - spin lock이라고도 부르며, sleep, wake-up 시그널의 context switching을 거치지 않으므로 효율적이다.
  - 조건 변수를 사용하여 lock이 empty일 때까지 sleep하도록 설정한다.
![image](/image/mutex.png)
- acquire lock에서는 lock을 얻을 수 있을 때까지 기다리고, 획득 시 critical section으로 들어간다.
- release lock에서는 lock을 반납한다.

#### 교착상태 (Deadlock) //ch 8
- 정의:
  - 둘 이상의 프로세스가 다른 프로세스가 점유하고 있는 자원을 서로 기다릴 때 무한 대기에 빠지는 상황이다.
- 특징:
  - 일어나지 않을 사건을 기다리며 발생한다.
  - 데드락 상황을 확인하기 위해, 자원 할당 그래프를 이용하여 확인할 수 있다.
  - 자원 할당 그래프가 원의 형태를 띄고 있으면 데드락이 발생한다.
  - 4가지의 데드락 조건을 모두 만족한다면 데드락이 발생할 수 있다.
##### 교착상태의 조건 (Conditions for Deadlock)
1. 상호 배제(Mutual Exclusion)
- 정의:
  - 자원은 한 번에 한 프로세스만 사용할 수 있는 상태이다.
- 특징:
  - 자원은 다른 프로세스가 사용하지 못하도록 제한한다.
  - 여러 프로세스가 동일한 자원을 요청할 때, 자원에 대한 경쟁이 발생한다.
  
2. 점유와 대기(Hold and Wait)
- 정의:
  - 프로세스가 최소한 하나의 자원을 점유하고 있으면서 동시에 추가 자원을 요청하는 상태이다.
- 특징:
  - 프로세스가 이미 자원을 사용하고 있어 추가 자원을 요청할 수 있다.
  - 프로세스는 다른 자원에 대한 요청을 하면서 대기 상태에 들어간다.
 
3. 비선점(No Preemption)
- 정의:
  - 이미 점유된 자원은 강제로 빼앗을 수 없는 상태이다.
- 특징:
  - 자원을 점유하고 있는 프로세스가 자원을 반환하기 전까지 다른 프로세스가 해당 자원을 사용할 수 없다.
  - 프로세스가 자원을 반환하지 않는 한, 대기 중인 프로세스는 계속 대기해야 한다.

4. 순환 대기(Circular wait)
- 정의:
  - 프로세스들이 원의 형태로 자원을 대기하는 상태이다.
- 특징:
  - 프로세스들이 서로를 기다리는 순환적 구조이다.
  - 대기 관계가 복잡해져 시스템이 멈출 수 있다.

##### 교착상태 해결 방법 (Deadlock Handling) - 예방(Prevention), 회피(Avoidance), 탐지(Detection), 복구(Recovery)
1. 예방(Prevention)
- 정의:
  - 네 가지 교착 상태 중 하나 이상을 방지한다.
- 특징:
  - 상호 배제 부정
    - 읽기 전용 파일과 같은 공유 자원을 사용한다.
  - 점유와 대기 부정
    - 프로세스 대기를 없애기 위해서 프로세스가 실행되기 전에 필요한 모든 자원을 할당한다.
    - 자원을 점유하지 않고 있을 때에만 다른 자원을 요청할 수 있도록 한다.
  - 비선점 부정
    - 모든 자원에 대한 선점을 허용한다.
    - 프로세스가 할당받을 수 없는 자원을 요청하는 경우, 기존에 가지고 있던 자원을 모두 반납하고 새 자원과 이전 자원을 얻기 위해 대기하도록 한다.
  - 순환 대기 부정
    - 자원에 고유한 번호를 할당하고, 번호 순서대로 자원을 요구하도록 한다.

2. 회피(Avoidance)
- 정의:
  - 교착 상태가 발생하기 전에 교착 상태를 예상하여 안전한 상태(safe state)에서만 자원 요청을 허용하는 방법이다.
- 특징:
  - 4가지의 가정이 필요하다
    - 프로세스의 수가 고정되어 있어야 한다.
    - 자원의 종류와 수가 고정되어 있어야 한다.
    - 프로세스가 요구하는 자원 및 최대 자원 수를 알아야 한다.
    - 프로세스는 반드시 자원을 사용 후 반납해야 한다.
  - 위 가정이 필요하므로, 현실성이 부족하다.
  - safe state란 safe sequence가 존재하여 모든 프로세스가 정상적으로 종료할 수 있는 상태
  - unsafe state란 교착 상태가 될 수 있는 상태
  - 회피를 위한 알고리즘 2가지
    - Resource-Allocation Graph Algorithm
    - Banker's Algoritm

3. 탐지(Detection)
- 정의:
  - 탐지 알고리즘을 사용하여 교착상태가 발생했는 지 탐지하는 방법이다.
- 특징:
  - 교착 상태가 탐지되었을 경우 복구 기법을 통해 복구한다.
  - 지속적인 상태 탐지과정이 필요하므로 성능 저하가 발생한다.
  - 탐지를 위한 알고리즘
    - wait-for graph
    - banker's algorithm

4. 복구(Recovery)
- 정의:
  - 교착 상태가 발생했다면, 교착 상태를 발생시킨 프로세스를 종료하거나 할당된 자원을 해제함으로 복구한다.
- 특징:
  - 교착 상태에 있는 프로세스를 종료하는 방법이 있다.
    - 교착 상태의 모든 프로세스를 중지하거나 한 프로세스씩 해결될 때까지 제거한다.
  - 교착 상태에 있는 프로세스가 점유한 자원을 다른 프로세스에 할당하여 해당 프로세스를 일시 정지시키는 방법이 있다.
  - 고려 조건
    - 희생자 선택 : 최소의 피해를 줄 수 있는 프로세스를 선택한다.
    - 롤백 : 선점된 프로세스를 문제가 없는 이전 상태로 롤백해야 한다.
    - 기아 상태 : 한 프로세스가 계속 선점되어 기아상태가 되는 것을 방지해야 한다.

## 메모리 관리 (Memory Management)

#### 메모리 계층 구조 (Memory Hierarchy)
![image](/image/MemoryHierarchy.png)
https://www.cs.swarthmore.edu/~kwebb/cs31/f18/memhierarchy/mem_hierarchy.html
- 정의: 
  - 다양한 종류의 메모리를 속도와 용량, 비용에 따라 계층적으로 배열한 것
- 특징:
  - CPU와 메모리 간의 성능 차이를 최소화하고, 효율적인 데이터 처리를 위해 설계됨
1. 레지스터(Register)
    - CPU 내부에 위치한 가장 빠른 메모리로, CPU가 직접 접근할 수 있는 소량의 데이터 저장소
    - 매우 빠른 접근 속도를 가지고 용량이 작다.
2. 캐시 메모리(Cache Memory)
    - CPU 내부에 위치한 가장 빠른 메모리로, CPU가 직접 접근할 수 있는 소량의 데이터 저장소
    - 매우 빠른 접근 속도를 가지고 용량이 작다.
3. 주 메모리(Main Memory)
    - 주로 DRAM(Dynamic Random Access Memory)으로 구성되어 있으며, 프로그램과 데이터를 일시적으로 저장
    - 접근 속도는 캐시보다 느리고, 전원이 꺼지면 데이터가 사라진다.
4. 보조 저장 장치(Secondary Storage)
    - 데이터를 영구적으로 저장하는 장치로, HDD, SSD, Flash Disk 등이 있다.
    - 접근 속도가 느리고, 대용량 데이터를 저장할 수 있다.
    - 비휘발성 메모리로 전원이 꺼져도 데이터가 유지된다.
5. 원격 보조 저장장치(Remote Secondary Storage)
    - 클라우드 스토리지나 외부 저장 장치 등으로, 주로 데이터 백업이나 아카이빙에 사용된다.
    - 접근 속도가 가장 느리고, 일반적으로 인터넷을 통해 접근한다.


#### 주기억장치 관리 (Main Memory Management)

##### 단순 관리 (Simple Management) - 고정 분할(Fixed Partition), 가변 분할(Variable Partition)
1. 고정 분할(Fixed Partition)
- 정의:
  - 물리적 메모리를 정해진 개수만큼의 영구적인 분할로 나누어두고 각 분할에 하나의 프로세스를 적재하는 방식
- 특징:
  - 메모리를 고정된 크기의 여러 파티션으로 나누어 각 프로세스에 할당한다.
  - 각 파티션의 크기는 일정하고, 프로세스는 해당 파티션에 완전히 적합해야 한다.
  - 파티션의 수는 시스템 부팅 시 결정되고, 변경될 수 없다.
- 장점:
  - 구현이 간단하고, 파티션 관리가 용이하다.
  - 프로세스가 메모리에 할당되는 데 필요한 시간이 짧다.
- 예시
  - 초기 운영체제에서 사용했다.
  - 단순한 임베디드 시스템에서 고정된 적업 수행 시 사용한다.
  - 내부 단편화 문제가 발생한다.


2. 가변 분할(Variable Partition)
- 정의:
  - 프로세스의 크기에 따라 가변적인 크기의 파티션을 생성하는 방식이다.
- 특징:
  - 프로그램의 크기를 고려해서 메모리를 할당하고, 이를 기술적으로 관리할 수 있는 기법이 필요하다.
- 장점:
  - 프로세스에 필요한 만큼의 메모리만 할당하여 내부 단편화가 적다.
  - 프로세스의 크기에 따라 파티션을 동적으로 조정할 수 있다.
- 단점: 
  - 외부 단편화 문제가 발생한다.
  - 메모리 관리가 복잡해지고, 파티션을 동적으로 관리해야 하므로 오버헤드가 발생할 수 있다.
- 예시:
  - 현대 운영 체제에서 사용(Windows, Linux 등)

##### 페이징(Paging)과 세그멘테이션(Segmentation)
1. 페이징(Paging)
- 정의:
  - 프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 물리적 메모리의 서로 다른 위치에 페이지들을 저장하는 방식이다.
- 특징:
  - 페이징 기법에서는 각 프로세스의 주소 공간 일부는 백킹스토어에, 일부는 물리적 메모리에 혼재시키는 것이 가능하다.
  - 물리적 메모리를 페이지와 같은 크기의 프레임으로 미리 나누어서, 빈 프레임에 어느 위치든 사용가능하게 한다.
- 장점:
  - 동적 메모리 할당 문제가 발생하지 않는다.
  - 메모리상의 가용 공간의 크기가 작아서 외부 조각 문제가 발생하지 않는다.
- 단점:
  - 내부 조각이 발생할 수 있다.

2. 세그멘테이션 (Segmentation)
- 정의:
  - 프로세스의 주소공간을 의미 단위의 세그먼트(segment)로 나누어 물리적 메모리에 올리는 방법이다.
- 특징:
  - 메모리를 논리 단위로 나누어서, 세그먼트의 크기가 균일하지 않다.
  - 기능 단위로 세그먼트를 정의한다.
- 동작 방식:
  - 프로세스가 메모리에 접근할 때, 세그먼트 번호와 오프셋으로 주어진다. 세그먼트 번호를 사용해 세그먼트 테이블을 조회한다.
  - 세그먼트 번호를 사용하여 세그먼트 테이블에서 해당 세그먼트의 시작 주소와 길이를 찾는다.
  - 세그먼트의 시작 주소와 offset을 더하여 물리 주소를 생성한다.
- 장점:
  - 프로세스의 필요에 따라 가변 크기의 세그먼트를 가져, 메모리를 효율적으로 사용한다.
  - 프로그램의 논리적 구조를 반영하여, 코드와 데이터
- 단점:
  - 물리적 메모리 관리에서 외부 조각이 발생한다.


##### 페이징과 세그멘테이션의 조합
- 정의:
  - 세그멘테이션과 페이징 기법을 결합한 메모리 관리 기법으로, 프로세스의 논리 주소 공간을 논리적 단위인 세그먼트로 나눈 후, 각 세그먼트를 고정 크기의 페이지로 나누어 물리적 메모리에 매핑하는 방식이다.
- 특징:
  - 프로세스는 여러 개의 세그먼트로 나뉘며, 각 세그먼트는 다시 페이지로 나뉜다.
  - 각 세그먼트의 크기는 프로세스의 요구에 따라 다를 수 있다.
  - 페이지는 고정된 크기로 설정된다.
- 동작 방식:
  - 프로세스가 메모리에 접근할 때, 세그먼트 번호를 사용하여 세그먼트 테이블에서 해당 세그먼트의 페이지 테이블 위치를 찾는다.
  - 페이지 번호를 사용하여 세그먼트 페이지 테이블에서 물리적 프레임 번호를 찾는다.
  - 물리적 프레임 번호와 오프셋을 결합하여 최종 물리 주소를 생성한다.
- 장점:
  - 세그먼트의 크기가 가변적이므로, 다양한 크기의 프로세스를 효과적으로 관리할 수 있다.
  - 페이지 단위로 메모리를 관리하여 내부 단편화를 줄이고, 외부 단편화 문제를 완화한다.
  - 필요한 페이지만 메모리에 로드할 수 있어, 메모리를 효율적으로 사용할 수 있다.
- 단점:
  - 페이징과 세그멘테이션의 결합으로 메모리 관리가 복잡해질 수 있다.
  - 각 세그먼트마다 페이지 테이블을 유지해야 하므로, 메모리 오버헤드가 증가한다.

#### 가상 메모리 (Virtual Memory) //ch10
- 정의:
  - 프로그램이 더 많은 메모리를 사용할 수 있도록 하드 드라이브의 일부를 메모리처럼 사용하는 기술이다.
- 특징:
  - 운영 체제에서 가상 주소를 물리적 주소로 변환하여 사용한다.
  - MMU(Memory Management Unit)을 이용하여 가상 메모리 주소를 실제 메모리 주소로 변환하여 두 메모리를 대응한다.

##### 페이지 교체 알고리즘(Page Replacement Algorithms) - FIFO, LRU, Optimal
1. FIFO(First-In-First-Out)
- 정의:
  - 물리적 메모리에 가장 먼저 올라온 페이지를 교체하는 방법.
- 동작 방식:
![image](/image/fifo.png)
https://wookcode.tistory.com/184 
    1. 참조한 페이지 번호를 프레임에 저장
    2. 가장 오래 있었던 페이지를 교체한다.
- 단점:
  - Bealady's Anomaly
    - Page frame을 증가시켜도 page fault가 감소하지는 않거나 오히려 증가하는 경우.

2. LRU(Least Recently Used)
- 정의:
  - 가장 오랫동안 사용되지 않은 페이지를 교체하는 방법이다.
- 특징:
  - 페이지가 참조될 때마다 시간을 리스트에 기록한다.
  - 많은 OS에서 채택하는 알고리즘이다.
- 동작 방식:
![image](/image/LRU.png) 
https://yclib.dkyobobook.co.kr/main.ink
    1. 카운터나 스택을 통해 참조 시간을 기록한다.
    2. 가장 오랫동안 참조되지 않은 페이지를 교체한다.
- 장점:
  - 페이지 교체 횟수가 높지만 효율적이다.
- 단점:
  - 프로세스가 메모리에 접근할 때마다 페이지 시간을 기록해야 하므로, 막대한 오버헤드가 발생한다.

3. Optimal Replacement
- 정의:
  - 가장 오랫동안 사용되지 않을 페이지를 교체하는 방법이다.
- 특징:
  - 가장 이상적이고 효율적인 방법이다.
- 동작 방식:
![image](/image/opt.png)
https://wookcode.tistory.com/184     
    1. 5번 째 프레임에서, 1의 쓰임이 가장 마지막임을 알고있기 때문에 미리 교체함.
- 장점:
  - 모든 방법 중에서 페이지 교체 수가 가장 적다.
  - 가장 낮은 페이지 폴트율
- 단점:
  - 실제 시스템에서는 구현이 불가능하다.

##### 스왑 공간 관리 (Swap Space Management)
- 정의:
  - 시스템의 물리적 메모리(RAM)가 부족할 때, 프로세스의 데이터를 하드 드라이브(또는 SSD)와 같은 보조 기억 장치로 이동하여 메모리 공간을 확보하는 기술이다.
- 특징:
  - 실제 RAM의 용량을 초과하여 더 많은 데이터를 처리할 수 있다.
  - 일반적으로 물리적 메모리보다 처리 속도가 느리다.
  - 일시적인 메묄 부족 상황을 해결하기 위한 장치이다.
  - 스왑 공간에는 스왑 파일, 스왑 파티션으로 구성된다.
    - 스왑 파일: 운영 체제의 파일 시스템 내에 존재하는 파일로, 스왑 공간으로 사용된다.
    - 스왑 파티션: 하드 드라이브의 특정 파티션을 스왑 공간으로 지정하는 방식이다.
    - 
  ![image](/image/swap.png)
  - 일시적으로 swap out을 통해 프로세스를 보조기억장치에 저장한다.
  - 이후 swap in을 통해 임시로 저장했던 프로세스를 가져온다.


## 파일 시스템 (File System) 

#### 파일의 개념과 구조 (Concept and Structure of Files)
- 정의:
  - 데이터를 저장하고 관리하는 기본 단위이다.
- 특징:
  - 파일에는 이름으로 접근한다.
  - 파일은 레코드(Record) 혹은 블록(Block) 단위로 비휘발성 보조기억장치에 저장된다.
  - 파일의 속성에는 크기, 생성 날짜, 수정 날짜, 권한 등이 존재한다.
  - 파일 생성, 삭제, 열기, 닫기 등의 연산을 위해 System Call을 사용한다.
  - 파일의 메타데이터를 저장한, 디렉토리를 이용하여 파일들을 관리한다.
#### 디렉토리 구조 (Directory Structure)
- Window 운영체제에서는 폴더라고 지칭한다.
##### 단일 레벨(Single Level), 다중 레벨(Multi-Level), 트리 구조(Tree Structure)
1. 단일 레벨 디렉토리
  - 정의:
    - 하나의 디렉토리 아래에 모든 파일이 존재하는 구조이다.
  - 특징:
  ![image](/image/singledirectory.png)
  Operating System Concept
    - 디렉토리의 수가 1개이다.
  - 장점:
    - 구현이 간단하고, 파일 접근이 용이하다.
  - 단점:
    - 파일 수가 많아질 수록 관리가 어려워지고, 파일 이름 충돌이 발생할 수 있다.

2. 다중 레벨 디렉토리
  - 정의:
    - 중앙에 마스터 파일 디렉토리(MFD)가 있고, 그 아래에 사용자별로 서로 다른 파일 디렉토리(UFD)가 있는 2계층 구조이다.
  - 특징:
  ![image](/image/multidirectory.png)
  Operating System Concept
    - 각 사용자들의 이름이나 계정 번호, 그리고 사용자 파일 디렉토리를 가리키는 포인터를 갖고 있고, 사용자 파일 디렉토리를 관리한다.
    - UFD는 오직 한 사용자가 갖고 있는 파일들에 대한 정보만 갖고 있고, 해당 사용자의 파일을 관리한다.
  - 장점:
    - 파일 이름 중복의 문제를 방지할 수 있다.
  - 단점:
    - 각 사용자는 다른 사용자의 파일 디렉토리를 검색할 수 없으므로 업무 협력 및 파일의 공유가 어렵다.

3. 트리 구조
  - 정의:
    - 하나의 루트 디렉토리와 여러 개의 종속(서브) 디렉토리로 구성된 구조이다.
  - 특징:
  ![image](/image/treedirectory.png)
  Operating System Concept
    - 사용자들이 자신의 서브 디렉토리(Sub Directory)를 만들어서 파일을 구성할 수 있다.
    - 각 사용자는 하나의 루트 디렉토리를 가진다.
    - DOS, Windows, UNIX 등의 운영체제에서 사용되는 디렉토리 구조이다.
  - 장점:
    - 파일과 디렉토리를 체계적으로 조직할 수 있어, 대규모 파일 시스템에서 효율적으로 관리 가능하다.
    - 파일 이름 충돌을 방지할 수 있다.
  - 단점:
    - 구조가 복잡해질 수 있어, 원하는 파일을 찾는 데 시간이 걸릴 수 있다.

#### 파일 할당 방법 (File Allocation Methods)

##### 연속 할당(Contiguous Allocation), 연결 할당(Linked Allocation), 색인 할당(Indexed Allocation)
1. 연속 할당(Contiguous Allocation)
- 정의:
  - 연속된 블록에 파일을 할당하는 방식이다.
- 특징:
  - 메모리 블럭이 연속적으로 배치된다.
  - 파일 시스템이 간단하다.
- 장점:
  - 접근 속도가 빠르다.
  - 관리가 요잉하고, 데이터의 위치가 고정적이다.
- 단점:
  - 파일의 크기가 변동되면 재배치가 필요할 수 있다.
- 예시:
  - 간단한 파일 시스템

2. 연결 할당(Linked Allocation)
- 정의:
  - LinkedList와 같은 방식으로 각 블럭이 포인터로 연결된 방식이다.
- 특징:
  - 각 블럭이 다른 블럭을 가리키는 링크를 가진다.
  - 데이터가 비연속적으로 저장된다.
- 장점:
  - 동적으로 파일 크기를 조정할 수 있다.
  - 파일의 크기와 수에 유연하게 대처 가능하다.
- 단점:
  - 데이터 접근 시 포인터를 따라가야 하므로 속도가 느릴 수 있다.
  - 링크 저장을 위한 추가적인 메모리가 소모된다.
- 예시:
  - 데이터베이스 관리 시스템

3. 색인 할당(Indexed Allocation)
- 정의:
  - 각 파일에 대한 인덱스 블럭이 존재하고, 인덱스는 데이터 블럭의 위치를 가리키는 방식이다.
- 특징:
  - 인덱스 블럭이 데이터 블럭의 주소를 저장한다.
  - 데이터 블럭은 비연속적으로 저장될 수 있다.
- 장점:
  - 빠른 데이터 접근 속도
- 단점:
  - 인덱스 블럭의 크기가 커질 경우 오버헤드가 발생한다.
  - 인덱스를 관리하기 위한 추가 메모리가 필요하다.
- 예시:
  - 대형 데이터베이스 시스템

#### 파일 시스템 구현 (File System Implementation)
- 정의:
  - 파일과 디렉토리를 보조기억장치에 일목요연하게 저장하고 접근할 수 있게 하는 운영체제 내부 프로그램이다.
- 특징:
  - 커널 영역에서 동작한다.
  - 계층적 디렉토리 구조를 가진다.
  - 파일의 데이터가 저장된 데이터 영역과, 파일의 정보가 저장된 메타 영역으로 나뉜다.
- 예시
  - FAT, ext, HFS
##### 디스크 스케줄링 알고리즘 (Disk Scheduling Algorithms) - FCFS, SSTF, SCAN, C-SCAN 등
1. FCFS (First-Come, First-Served, 선입선출)
- 정의:
  - 요청을 도착한 순서대로 처리하는 디스크 알고리즘이다.
- 특징:
  - 단순한 접근 방식이다.
  - 비효율적일 수 있고, 탐색 시간이 길 수 있다.
- 작동 방식:
![image](/image/fcfs.png)

  ```java
  public class FCFSExample {
    public static void main(String[] args) {
        int[] requests = {98, 183, 37, 122, 14, 124, 65, 67};
        int head = 53; // 초기 헤드 위치
        for (int request : requests) {
            int movement = Math.abs(request - head);
            System.out.println("Moved from " + head + " to " + request + " (Distance: " + movement + ")");
            head = request;
        }        
    }
  }
  ```

2. SSTF (Shortest Seek Time First, 최단 탐색 시간 우선)
- 정의:
  - 현재 헤드의 위치에서 가장 가까운 요청을 우선적으로 처리하는 디스크 알고리즘이다.
- 특징:
  - 요청 패턴이 일정할 경우, 예측 가능한 성능을 제공한다.
  - 응답 시간의 편차가 크다.
- 작동 방식:
  - head의 위치를 기준으로 가장 가까운 거리에 있는 요청을 처리한다.
  ```java
  public class SSTF {
      public static void main(String[] args) {
          // 디스크 요청 큐 및 초기 헤드 위치
          List<Integer> requestList = new ArrayList<>(Arrays.asList(98, 183, 37, 122, 14, 124, 65, 67));
          int head = 53;
          while (!requestList.isEmpty()) {
              // 가장 가까운 요청 찾기
              int closestRequest = -1;
              int shortestDistance = Integer.MAX_VALUE;
              for (int request : requestList) {
                  int distance = Math.abs(request - head);
                  if (distance < shortestDistance) {
                      shortestDistance = distance;
                      closestRequest = request;
                  }
              }
              // 헤드를 가장 가까운 요청으로 이동

              System.out.println("Moved from " + head + " to " + closestRequest + " (Distance: " + shortestDistance + ")");
              head = closestRequest;

              // 처리된 요청 제거
              requestList.remove(Integer.valueOf(closestRequest));
          }
      }
  }
  ```

3. SCAN
- 정의:
  - 헤드가 한 방향으로 이동하면서 경로상의 모든 요청을 처리하는 알고리즘이다.
- 특징:
  - 디스크 끝에 도달하면 방향을 반대로 바꾼다.
  - FCFS보다 효과적이다.
- 작동 방식:
![image](/image/scan.png)
  ```java
  public class SCAN {
      public static void main(String[] args) {
          // 디스크 요청 큐 및 초기 헤드 위치
          List<Integer> requestList = new ArrayList<>(Arrays.asList(98, 183, 37, 122, 14, 124, 65, 67));
          int head = 53;
          int diskSize = 200; // 디스크의 총 크기 (0 ~ diskSize-1)
          boolean direction = true; // true: 오른쪽, false: 왼쪽
          // 요청 큐 정렬
          Collections.sort(requestList);

          while (!requestList.isEmpty()) {
              if (direction) {
                  // 헤드 오른쪽으로 이동
                  Iterator<Integer> iterator = requestList.iterator();
                  while (iterator.hasNext()) {
                      int request = iterator.next();
                      if (request >= head) {
                          System.out.println("Moved from " + head + " to " + request + " (Distance: " + distance + ")");
                          head = request;
                          iterator.remove();
                      }
                  }
                  // 디스크의 끝에 도달하면 방향 변경
                  System.out.println("Reached end of disk at position " + (diskSize - 1));
                  head = diskSize - 1;
                  direction = false;
              } else {
                  // 헤드 왼쪽으로 이동
                  ListIterator<Integer> iterator = requestList.listIterator(requestList.size());
                  while (iterator.hasPrevious()) {
                      int request = iterator.previous();
                      if (request <= head) {
                          int distance = Math.abs(request - head);
                          System.out.println("Moved from " + head + " to " + request + " (Distance: " + distance + ")");
                          head = request;
                          iterator.remove();
                      }
                  }
                  // 디스크의 시작에 도달하면 방향 변경
                  head = 0;
                  direction = true;
              }
          }
      }
  }
  ```
4. C-SCAN (Circular SCAN, 순환 SCAN)
- 정의:
  - 헤드가 한 방향으로 이동하면서 경로상의 모든 요청을 처리하는 알고리즘이다.
- 특징:
  - SCAN 알고리즘을 개선한 알고리즘이다.
  - 헤드가 한 방향으로 이동하며 요청을 처리한다.
  - 끝에 도달했을 때, 데이터를 읽지 않고 처음 위치로 바로 이동한다.
- 작동 방식:
![image](/image/cscan.png)
  - SCAN 알고리즘의 소스코드에서 끝에 도달했을 때, iterator를 다시 수행한다.

##### 파일 시스템 무결성 (File System Integrity) - 저널링(Journaling), RAID(Redundant Array of Independent Disks)
1. 저널링(Journaling)
- 정의:
  - 스토리지에 데이터를 저장하기 전에 저널 영역에 데이터의 변경 이력을 저장하고, 스토리지 데이터 변경 내역을 저장하는 활동이다.
- 특징:
  - 사용자가 어떤 내용을 입력, 수정 시에는 작업 내용을 기록하고, 데이터를 저장한다.
  - 비정상적인 종료 발생 시 기록된 내용을 통해 복구한다.
- 장점:
  - 빠른 복구가 가능하다.
- 단점:
  - System call 수준에서 일관성을 유지하기 때문에, write()를 여러 번 사용하는 작업 중간에 장애 발생 시에 데이터의 복사가 완전하지 않을 수 있다.
  - 파일 시스템을 업데이트 할 때마다, 로깅에 따른 오버헤드와 I/O가 많아져 관리가 필요하다.

2. RAID(Redundant Array of Independent Disks)
- 정의:
  - 여러 개의 물리적 하드 디스크를 결합하여 하나의 논리적 드라이브로 구성하는 기술이다.
- 특징:
  - 외부에서는 하나의 디스크로 간주한다.
  - 내부에는 여러 개의 디스크와 메모리, 시스템을 관리하기 위한 프로세서 등으로 이루어져있다.
- 장점:
  - 디스크 여러 개를 병렬적으로 사용하므로, I/O 시간이 개선되어 성능상 이점이 있고, 더 큰 용량의 데이터를 저장할 수 있다.
  - 여러 디스크에 분산되어 저장하므로, 가용성을 높일 수 있다.
- 단점:
  - 여러 개의 물리적 디스크가 필요하므로, 비용이 증가할 수 있다.
  - RAID 배열을 설정하고 관리하는 데 추가적인 기술이 필요하다.

## 입출력 관리 (I/O Management)
#### I/O 하드웨어와 소프트웨어 (I/O Hardware and Software)
- 정의:
  - I/O 하드웨어는 컴퓨터 시스템이 외부와 상호작용할 수 있도록 하는 물리적 장치이다.
  - I/O 소프트웨어는 I/O 하드웨어를 제어하고, 데이터의 입출력을 관리하는 소프트웨어이다.
- 특징:
  ![image](/image/kernelio.png) 
  - I/O 하드웨어에는 입력 장치, 출력 장치, 저장 장치, 네트워크 장치가 있다.
  - I/O 소프트웨어는 장치 드라이버, I/O 관리 서브시스템, 파일 시스템이 있다.
  - Port, Bus, Controller를 통해서 하드웨어와 소프트웨어가 신호를 주고 받는다.

#### 장치 드라이버의 역할 (Role of Device Drivers)
- 정의:
  - 장치 컨트롤러의 동작을 감지하고 제어함으로써 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있게 하는 프로그램이다.
- 역할:
  - 하드웨어와의 통신
  - 장치 초기화 및 설정
  - 데이터 전송 관리
  - 장치 상태 모니터링

#### 인터럽트와 폴링 (Interrupts and Polling)
1. 인터럽트(Interrupts)
- 정의:
  - 인터럽트란 I/O 장치가 CPU에 데이터를 전송할 준비가 되었을 때, 또는 특정 이벤트가 발생했을 때 CPU에게 알리는 방식이다.
- 특징:
  - 비동기식 통신으로 장치가 준비되면 CPU에 신호를 보내, CPU가 현재 작업을 중단하고 장치의 요청을 기다린다.
  - CPU는 I/O의 작업을 기다리지 않고, 다른 작업 수행 가능하다.
- 처리 과정:
  ![image](/image/interruptio.png) 
  1. I/O 장치가 데이터를 전송할 준비가 되면 인터럽트를 발생시킨다.
  2. CPU는 현재 실행 중인 작업을 중단하고, 인터럽트 처리 루틴으로 전환한다.
  3. CPU는 인터럽트 서비스 루틴(ISR)을 실행하여 장치의 요청을 처리한다.
  4. 요청 처리 후, CPU는 이전 작업 상태로 복원하고 계속 실행한다.
- 장점:
  - CPU 자원을 효율적으로 사용할 수 있다.
  - 응답 시간이 짧고, 실시간 처리에 유리하다.
- 단점:
  - 처리 로직이 복잡하고, 우선순위 관리 및 충돌 처리가 필요하다.
  - 인터럽트가 자주 발생하면 오히려 성능 저하를 초래한다.

2. 폴링(Polling)
- 정의:
  - 폴링이란 CPU가 주기적으로 I/O 장치의 상태를 확인하여 데이터가 준비되었는지 또는 장치가 사용할 수 있는지 체크하는 방식이다.
- 특징:
  - 동기식 통신으로 CPU가 주기적으로 장치의 상태를 확인하여, 데이터가 준비되었는지 체크한다.
  - 시스템이 간단하여, 적은 수의 장치에서 사용하기 적합하다.
- 처리 과정:
  1. CPU가 주기적으로 I/O장치의 busy bit의 상태를 확인한다.
  2. CPU는 write bit를 설정하고, data-out register에 데이터를 작성한다.
  2. CPU는 전송할 데이터가 존재하면, command-ready bit을 변경한다.
  3. I/O 장치가 준비되면, Controller는 busy bit을 1로 변경하고, 전송을 수행한다.
  4. 전송이 완료되면, Controller는 busy bit, error bit, command-ready bit을 0으로 초기화한다.
  5. 위 과정을 반복한다.
- 장점:
  - 구현이 간단하고, 시스템 설계가 용이하다.
- 단점:
  - 장치가 준비되지 않은 경우에도 계속 체크하므로, CPU의 부담이 크다.
#### DMA (Direct Memory Access) 
- 정의:
  - CPU가 직접 개입하지 않고도 I/O 장치가 메모리에 데이터를 전송할 수 있도록 하는 방식이다.
- 특징:
    - 시스템 버스에 연결된 DMA 컨트롤러라는 하드웨어를 통해 DMA 입출력이 가능하다.
    - CPU의 개입을 최소화 할 수 있다.
- 입출력 과정
    ![image](/image/dma.png)
    1. CPU 는 DMA 컨트롤러에 입출력장치의 주소, 수행할 연산 (읽기/쓰기), 읽거나 쓸 메모리의 주소 등과 같은 정보로 입출력 작업을 명령한다.
    2. DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업을 수행한다. 이때 DMA 컨트롤러는 필요한 경우 메모리에 직접 접근하여 정보를 읽거나 쓴다.
    3. 입출력 작업이 끝나면 DMA 컨트롤러는 CPU에 인터럽트 요청을 걸어, 작업이 끝났음을 알린다.
- 장점:
  - CPU의 부하를 줄여, 시스템의 전체적인 성능을 높인다.
- 단점:
  - DMA 컨트롤러가 필요하므로, 추가적인 하드웨어 비용이 필요하다.

## 운영체제의 보안 (Security in Operating Systems)
#### 사용자 인증 (User Authentication)
- 운영 체제에서는 대표적인 사용자 인증 방식으로 비밀번호를 사용한다.
1. 비밀번호(Password)
   - 정의:
     - 시스템, 애플리케이션 또는 서비스에 접근하기 위해 사용자가 입력하는 비밀 정보이다.
   - 특징:
     - 사용자의 신원을 확인하기 위한 목적과 디렉토리 및 파일에 접근을 제한하기 위한 목적으로 사용한다.
     - 리눅스에서는 사용자의 비밀번호가 /etc/shadow 파일에 해시 형태로 존재한다.
   - 동작 방식:
     - 각 사용자는 본인만 아는 문자열을 비밀번호로 설정한다.
     - 비밀번호는 SHA-256 등 해시 알고리즘으로 암호화를 거쳐 저장된다.
   - 장점:
     - 인증이 간단하고 직관적이다.
     - 비밀번호 인증 시스템의 구현과 유지 관리의 비용이 저렴하다.
   - 단점:
     - 무차별 대입 등 종종 쉽게 추측될 수 있다.
     - 사용자가 기억하지 못 할 경우, 재설정의 번거로움이 있다.

#### 접근 제어 (Access Control) - 접근 제어 리스트(ACL), 역할 기반 접근 제어(RBAC)
1. 접근 제어 리스트(ACL)
   - 정의:
     - 접근 제어 목록을 설정한 것으로, 파일과 디렉토리 별로 권한을 설정한 목록이다.
   - 특징:
     - 파일, 디렉토리 등 각 object 별로 설정한다.
     - 사용자보다, object의 수가 많은 경우에 사용한다.
   - 동작 방식:
  ![image](/image/acl.png)Unix에서의 ACL
     - 각 파일 또는 디렉토리 별로 파일 소유자, 소유자 그룹, 다른 사용자에 대해 read, write, execute 권한을 설정한다.
   - 장점:
     - 구현이 간단하다.
   - 단점:
     - 사용자 간 권한을 일임하는 환경에서는 부적합하다.
     - 사용자가 많고, 지속적으로 변화하는 환경에서는 부적합하다.

2. 역할 기반 접근 제어(RBAC)
   - 정의:
     - 접사용자의 역할에 따라 시스템 자원에 대한 접근 권한을 관리하는 보안 모델이다.
   - 특징:
     - 파일, 디렉토리 등 각 object 별로 설정한다.
     - 사용자보다, object의 수가 많은 경우에 사용한다.
   - 동작 방식:
    
    ![image](/image/rbac.png)

    Solaris 10에서의 RBAC
     - 시스템 관리자는 다양한 역할을 정의하고, 각 역할에 필요한 권한을 할당한다.
     - 사용자는 하나 이상의 역할에 할당되고, 해당 역할에 따라 부여된 권한을 통해 자원에 접근한다.
   - 장점:
     - 개별 사용자의 액세스 또는 오브젝트 권한을 구성해야 하는 것에 효율적이다.
     - 역할에 따른 권한을 쉽고 빠르게 알 수 있다.
     - 권한 관리에 대한 부담이 줄어든다.
   - 단점:
     - 역할이 중복되면, 필요 이상의 많은 권한을 부여받아 보안에 취약할 수 있다.
     - 현실과 정책의 불일치로, 역할을 별도로 계속 만들면서 중복되는 권한이 생긴다.
#### 암호화 및 데이터 보호 (Encryption and Data Protection)
- 특징:
  - 리눅스에서 네트워크 통신을 암호화하기 위해서는 OpenSSH를 사용한다.
1. OpenSSH
   - 정의:
     - 네트워크 통신에 사용되는 TLS, SSL 프로토콜을 구현하는 데 사용하는 툴킷이다.
   - 특징:
     - 대부분의 OS에서 이용할 수 있다.
     - 대칭 및 비대칭 키 암호화를 지원한다.
   - 장점:
     - 다양한 암호화 알고리즘과 프로토콜을 지원하여 기밀성과 무결성을 보장한다.
     - 다양한 OS 및 언어에서 지원한다.
   - 단점:
     - 초기 설정이 다소 복잡할 수 있다.
     - 리소스 소모가 크다.
#### 보안 정책과 공격 방지 기법 (Security Policies and Attack Mitigation) - 방화벽, IDS/IPS, 악성코드 탐지
1. 방화벽
   - 정의:
     -  네트워크 트래픽을 감시하고, 미리 정의된 보안 규칙에 따라 허용하거나 차단하는 보안 장치이다.
   - 특징:
     - IP 주소, 포트, 프로토콜 등을 기반으로 트래픽을 필터링한다.
     - 접근 통제, 인증, 감사 및 로깅 등의 기능을 한다.
     - 구현 방식에는 패킷 필터링 방식(Packet Filtering), 상태 추적 방식(Stateful Inspection), 어플리케이션 게이트웨이 방식(Application Gateway) 등이 있다.
   - 동작 방식:
    패킷 필터링 방식(Packet Filtering)
     - 데이터 링크 계층(OSI Layer 2)에서 네트워크 계층으로 전달되는 패킷을 가로채서 해당 패킷 안의 주소(IP)와 서비스 포트를 검색하여 정의된 보안 규칙에 따라 서비스의 접근 허용 여부를 결정한다.
   - 장점:
     - 외부 공격으로부터 네트워크를 보호한다.
   - 단점:
     - 프로그램 내부에 포함된 악성 소프트웨어는 탐지가 어려움.
     - 악의적인 내부 사용자의 공격을 방어하는 데 한계가 있음.
2. IDS/IPS(Intrusion Detection System/Intrusion Prevention System)
   - 정의:
     -  IDS는 네트워크나 시스템에서 발생하는 비정상적인 활동을 감지하고 관리자에게 경고하는 시스템이고, IPS는 이를 확장하여 비정상적인 트래픽을 실시간으로 차단하는 시스템이다.
   - 특징:
     - IDS는 침입 여부를 감지하고 알리는 것, IPS는 침입 이전에 방지하는 것을 목적으로 한다.
     - IDS는 네트워크의 외부, IPS는 네트워크의 내부에 위치한다.
   - 장점:
     - 실시간으로 공격을 탐지, 차단한다.
   - 단점:
     - 잘못된 탐지가 발생할 수 있다.
3. 악성코드 탐지
   - 특징:
     - 리눅스에서 사용 가능한 악성코드 탐지 도구는 Aircrack-ng, ClamAV 등이 있다.
## 분산 및 병렬 처리 (Distributed and Parallel Processing)

#### 분산 시스템의 개념과 특성 (Concepts and Characteristics of Distributed Systems)
- 정의:
  - 여러 개의 독립적인 컴퓨터가 네트워크를 통해 상호 작용하며 공동으로 작업을 수행하는 시스템이다.
- 특징:
  - 과부하를 줄일 수 있다.
  - 점진적인 자원을 확장할 수 있다.
  - 일부가 고장나더라도 나머지는 작동이 가능하다. 
- 구성 요소:
  - 노드(Node)
    - 독립적인 컴퓨터나 서버로, 분산 시스템의 구성 요소
  - 네트워크(Network)
    - 노드 간의 통신을 가능하게 하는 인프라
  - 공유 리소스(Shared Resources)
    - 데이터베이스, 파일 시스템 등 여러 노드가 접근할 수 있는 자원
- 장점:
  - 확장성
    - 분산 시스템은 워크로드 및 요구 사항에 따라 확장할 수 있다. 필요에 따라 분산 컴퓨팅 네트워크에 새 노드, 즉 더 많은 컴퓨팅 디바이스를 추가할 수 있다.
  - 가용성
    - 컴퓨터 중 하나가 작동하지 않더라도 분산 컴퓨팅 시스템은 정상적으로 작동한다. 개별 컴퓨터에 장애가 발생하더라도 계속 작동할 수 있으므로, 설계부터 내결함성이 보장된다.
  - 일관성
    - 분산 시스템의 여러 컴퓨터는 정보와 중복 데이터를 공유하지만, 이 시스템은 모든 컴퓨터에 걸쳐 자동으로 데이터 일관성을 관리한다. 따라서 데이터 일관성을 유지하면서 내결함성의 이점을 누릴 수 있다.
  - 투명성
    - 분산 컴퓨팅 시스템은 사용자와 물리적 디바이스를 논리적으로 분리한다. 개별 시스템의 설정 및 구성에 대한 걱정 없이 마치 단일 컴퓨터인 것처럼 시스템과 상호 작용할 수 있다. 여러 하드웨어, 미들웨어, 소프트웨어 및 운영 체제를 함께 사용하더라도 시스템이 원활하게 작동할 수 있다.
  - 효율성
    - 분산 시스템은 기반 하드웨어의 리소스 사용을 최적화화여 더 빠른 성능을 제공한다. 따라서 볼륨 급증으로 인한 시스템 장애나 고가의 하드웨어의 낮은 활용도에 대한 걱정 없이 모든 워크로드를 관리할 수 있다.
- 단점:
  - 시스템 설계 및 구현이 복잡하다.
  - 여러 노드 간의 데이터를 동기화하고 알관성을 유지하는 것이 어려울 수 있다.
- 예시
  - 금융에서의 개인별 보험료 제공
  - 
#### 클러스터링 및 로드 밸런싱 (Clustering and Load Balancing)
1. 클러스터링(Clustering)
   - 정의:
     - 여러 대의 컴퓨터를 병렬로 연결한 시스템으로, 여러 대의 컴퓨터를 하나의 컴퓨터처럼 사용하게 해주는 기술이다.
   - 특징:
     - 고가용성 (High Availability)
       - 서버 중 하나가 실패하더라도, 다른 서버가 이어 받아 작업을 처리할 수 있다.
     - 부하 분산 (Load Distribution)
       - 여러 서버가 동시에 작업을 수행하여, 전체 시스템의 부하를 분산시킨다.
     - 데이터 공유 (Data Sharing)
       - 여러 서버가 동일한 데이터에 접근할 수 있도록 하여 데이터 일관성을 유지한다.
     - 확장성 (Scalability)
       - 필요에 따라 서버를 추가하거나 제거할 수 있다.
   - 장점:
     - 장애가 발생해도 시스템이 계속 운영될 수 있다.
     - 서버를 쉽게 추가, 제거할 수 있다.
     - 여러 서버가 함께 작업하므로, 대량의 트래픽을 처리하는 데 유리하다.
   - 단점:
     - 시스템 설계 및 구현이 복잡하다.
     - 여러 서버 간의 데이터 동기화가 필요하고, 일관성에 대한 문제가 발생할 수 있다.
   - 예시:
     - 고가용성이 중요한 DB, Web 서버에서 사용한다.
2. 로드 밸런싱(Load balancing)
   - 정의:
     - 여러 서버 간에 클라이언트의 요청을 효율적으로 분산시키는 기술이다.
   - 특징:
     - 클라이언트의 요청을 여러 서버에 균등하게 분산시켜 각 서버의 부하를 최적화한다.
     - 가장 빠른 응답을 제공할 수 있는 서버에 요청을 전달하여 전체 시스템의 성능을 향상한다.
     - 각 서버의 상태를 모니터링하여, 실패한 서버에 요청을 전달하지 않도록 한다.
     - 서버를 추가하거나 제거할 때, 자동으로 트래픽을 재분배한다.
   - 예시:
     - 클라이언트의 요청을 효율적으로 분배하기 위한 환경
#### 병렬 처리와 병렬 컴퓨팅 (Parallel Processing and Computing)
- 정의:
  - 여러 프로세서 또는 프로세스가 동시에 여러 작업을 수행하는 기술이다.
- 특징:
  - 주어진 일을 여러 개의 작은 작업으로 나누어 여러 프로세스에서 동시에 처리한다.
  - 여러 작업이 동시에 처리되므로, 전체 작업의 처리 시간이 줄어든다.
  - 여러 CPU의 코어 및 프로세서를 사용하여 자원을 효율적으로 사용한다.
- 장점:
  - 복잡한 계산 문제를 효율적으로 해결할 수 있다.
- 단점:
  - 복잡한 하드웨어와 소프트웨어 아키텍처가 필요하다.
  - 병렬 알고리즘을 개발하고 유지 관리하는 것에 어려움이 있을 수 있다.
- 예시:
  - 수퍼컴퓨터의 기후 예측
  - 유전자 분석 등의 대규모 과학적 계산
#### 동기화와 일관성 유지 (Synchronization and Consistency)
- 정의:
  - 여러 노드나 프로세스 간에 작업을 조정하고, 공유 자원에 대한 접근을 관리하는 과정을 의미
- 특징:
  - 여러 프로세스가 동시에 공유 자원에 접근하지 못하도록 하는 메커니즘이다.
  - 분산 시스템 내의 여러 노드가 서로 다른 시간을 가질 수 있기 때문에, 이를 조정하여 일관된 상태를 유지한다.
- 장점:
  - 데이터의 일관성을 유지하고, 신뢰할 수 있는 정보를 제공한다.
- 단점:
  - 일관성을 유지하기 위해 많은 동기화 작업이 필요하다.
  - 다양한 일관성 모델을 구현하는 데 복잡하다.
- 예시:
  - 공유 파일 시스템
  - 은행 계좌 이체