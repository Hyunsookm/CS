# 컴퓨터구조

# 컴퓨터구조와 개요 (Introduction to Computer Architecture)

## 컴퓨터 구조란 무엇인가?

**컴퓨터 구조(Computer Architecture)**

- **정의**: 
  - 컴퓨터 시스템의 기능, 조직, 구현에 대한 법칙과 방법
  - 컴퓨터 시스템의 구성 요소와 그들 간의 상호 작용을 설명하는 개념으로, 하드웨어와 소프트웨어의 상호 작용을 포함

## 컴퓨터 시스템의 발전과 역사

1. 초기 계산 기계 (1940년대 이전)
   - 아날로그 컴퓨터를 사용함

2. 최초의 전자 컴퓨터 (1940년대)
   - ENIAC (Electronic Numerical Integrator and Computer): 세계 최초의 범용 전자 컴퓨터
   - 크기와 전력소모가 매우 컸고, 유지보수가 어려움

3. 트랜지스터와 통합 회로의 시대 (1950년대~1960년대)
   - 진공관을 대체한 트랜지스터를 사용한 컴퓨터 개발
   - IC회로의 도입으로 성능과 효율이 대폭 증가함

4. 미니컴퓨터와 개인용 컴퓨터의 발전 (1970년대)
   - 개인용 컴퓨터(PC, Personnal Computer)를 도입함
   - Intel 4004: 최초의 상용 마이크로프로세서

5. 네트워킹과 인터넷의 발전 (1980년대)
    - LAN(Local Area Network)을 통해 인터넷 상용화함

6.  모바일 컴퓨팅과 클라우드 컴퓨팅 (2000년대)
    - 모바일 장치 및 클라우드 컴퓨팅으로 어디서나 데이터에 접근할 수 있음

7.  인공지능과 머신러닝의 발전 (2010년대~현재)
    - 머신러닝과 딥러닝 기술의 발전으로 컴퓨터가 데이터를 학습하고 패턴을 인식함
    - 초고밀도 집적회로(VLSI)를 사용하여 초소형화, 초고속화가 이루어짐

## 컴퓨터의 구성 요소 (Components of a Computer System)

**중앙처리장치(CPU)**
![image](/main/cpu.png)

- **정의**: 
  - 컴퓨터 시스템의 두뇌 역할을 하며, 명령어를 해석하고 실행함
- **특징**: 
  - 컴퓨터 시스템의 핵심 구성 요소임
  - 데이터의 처리와 명령어의 실행을 담당함
  - 크게 산술 논리 장치, 제어 유닛, 레지스터로 구성됨 
  - 명령어의 사이클을 통해 순서대로 명령어를 실행한다.
**메모리(Memory)**

- **정의**: 
  - 컴퓨터 시스템 내에서 데이터와 명령어를 저장하고, 필요할 때 접근할 수 있도록 하는 하드웨어 장치
- **특징**:
  - 주기억장치(Primary memory)와 보조기억장치(Secondary Storage)로 구분됨
    - 주기억장치(Primary memory)
      - ROM(Read Only Memory) - 컴퓨터 전원이 끊어져도 기록된 데이터들이 소멸하지 않는 비휘발성 메모리로, BIOS와 같은 주요 데이터를 저장한다
      - RAM(Random Access Memory) - 전원이 끊어지면 기록된 데이터들이 소멸하는 휘발성 메모리이며, 읽고 쓰기가 가능함   

    - 보조기억장치(Secondary Storage)
      - HDD(Hard Disk Drive) - 자기 디스크를 사용해 데이터를 저장하는 장치, 회전하는 플래터와 읽기/쓰기 헤더를 이용함
      - SDD(Solid State Drive) - 반도체를 이용하여 데이터를 저장하는 장치, 플래시 메모리를 사용하고, HDD와 비교해 작교 가벼우며 처리 속도가 빠름
      - USB(Universal Serial Bus) - USB 포트에 꽂아 사용하는 이동형 저장장치, 플래시 메모리를 사용함  
  - 메모리 계층 구조
    - 필요에 따라 여러 종류의 메모리를 나눠 CPU가 순차적으로 액세스 함으로써 최적의 효율을 낼 수 있게 하는 구조
    - 계층 위로 올라갈 수록 접근 속도가 빠르고 저장 용량이 적어짐
    - 지역성의 원리(Principle of Locality)
      - 메모리는 지역성의 원리를 이용하여 계층적으로 구성
    - 시간적 지역성(Temporal locality)
      - 어떤 데이터가 참조되면 곧바로 다시 참조될 가능성이 높다는 원칙
    - 공간적 지역성(Spatial locality)
      - 어떤 데이터가 참조되면 곧바로 그 주위의 데이터가 참조될 가능성이 높다는 원칙
  ![image](/main/memory.png)

  1. 레지스터(Register)
    - CPU 내부에 위치한 가장 빠른 메모리로, CPU가 직접 접근할 수 있는 소량의 데이터 저장소
    - 매우 빠른 접근 속도를 가지고 용량이 작다.
  2. 캐시 메모리(Cache Memory)
      - CPU 내부에 위치한 가장 빠른 메모리로, CPU가 직접 접근할 수 있는 소량의 데이터 저장소
      - 매우 빠른 접근 속도를 가지고 용량이 작다.
  3. 주 메모리(Main Memory)
      - 주로 DRAM(Dynamic Random Access Memory)으로 구성되어 있으며, 프로그램과 데이터를 일시적으로 저장
      - 접근 속도는 캐시보다 느리고, 전원이 꺼지면 데이터가 사라진다.
  4. 보조 저장 장치(Secondary Storage)
      - 데이터를 영구적으로 저장하는 장치로, HDD, SSD, Flash Disk 등이 있다.
      - 접근 속도가 느리고, 대용량 데이터를 저장할 수 있다.
      - 비휘발성 메모리로 전원이 꺼져도 데이터가 유지된다.
  5. 원격 보조 저장장치(Remote Secondary Storage)
      - 클라우드 스토리지나 외부 저장 장치 등으로, 주로 데이터 백업이나 아카이빙에 사용된다.
      - 접근 속도가 가장 느리고, 일반적으로 인터넷을 통해 접근한다.

**입출력 장치 (I/O Devices)**

- **정의**: 
  - 컴퓨터 시스템과 외부 환경 간의 데이터 교환을 가능하게 하는 하드웨어 장치
- **특징**: 
  - 입력장치 - 키보드, 마우스, 터치스크린, 스캐너 등
  - 출력장치 - 모니터, 프린터, 스피커 등
  - 입출력장치 - 터치스크린, 모뎀, 네트워크 카드, 외장 하드 등

## 폰노이만 아키텍처 (Von Neumann Architecture) vs. 하버드 아키텍처 (Harvard Architecture)

**폰노이만 아키텍처 (Von Neumann Architecture)**
![image](/main/von.png)

- **정의**: 
  - 프로그램과 데이터를 동일한 메모리에 저장하고, CPU가 메모리에서 명령어를 순차적으로 가져와 실행하는 컴퓨터 설계 모델
- **특징**:
  - 프로그램과 데이터를 동일한 메모리에 저장함으로써, 프로그램의 수정과 데이터의 접근이 용이
  - 명령어를 순차적으로 처리함으로써, 프로그램의 흐름을 예측 가능하게 함
  - 한 번에 하나의 명령어만 실행 가능함
  - 하나의 메모리를 공유함
- **장점**: 
  - 공용 메모리 사용을 구현 비용이 상대적으로 저렴함
- **단점**: 
  - 파이프라이닝 시 메모리 공유 문제 발생함
  - 한 번에 하나의 명령어만 처리하므로 CPU를 비효율적으로 사용함

**하버드 아키텍처 (Harvard Architecture)**
![image](/main/havard.png)
- **정의**: 
  - 명령어와 데이터를 별도의 메모리 공간에 저장하고, 독립적인 버스를 통해 접근하는 컴퓨터 설계 모델
- **특징**: 
  - 파이프라인 구현을 위해, 명령어와 데이터를 별도의 메모리 공간에 저장함
  - 동시에 명령어 해석과 저장이 가능함
- **장점**: 
  - 명령어와 데이터에 동시 접근 가능하여 처리 속도 향상
  - 명령어와 데이터가 동일한 버스를 공유하지 않아 충돌 문제가 발생하지 않음
- **단점**: 
  - 메모리와 버스를 별도로 설계해야 하므로 하드웨어가 복잡함
  - 추가적인 메모리와 버스 설계로 인해 비용이 높아짐

## 컴퓨터 설계의 기본 원리 (Fundamental Principles of Computer Design)

**관심사 분리(Separation Of Concerns)**

- **정의**: 
  - 시스템이나 소프트웨어에서 각기 다른 기능이나 문제를 독립적으로 처리하도록 나누는 설계 원칙
- **특징**: 
  - 유지보수와 확장성이 용이함
  - 각 모듈은 독립적으로 변경, 개발이 가능함

**캡슐화와 추상화(Encapsulation and Abstraction)**

- **정의**: 
  - 캡슐화는 객체나 클래스의 내부 구현을 외부에서 숨기고, 필요한 기능만을 공개하는 원리임
  - 추사오하는 복잡한 시스템에서 중요하지 않거나 세부사항을 제거하고, 핵심 기능만을 드러내는 원리임
- **특징**: 
  - 캡슐화는 데이터와 그 데이터를 처리하는 메서드를 하나의 단위로 묶어 객체로 구현함
  - 추상화는 사용자가 시스템을 사용할 때 불필요한 세부사항을 몰라도 되게 하여, 복잡성을 줄이고 사용성을 높임

**느슨한 결합과 높은 응집력(Loose Coupling and High Cohesion)**

- **정의**: 
  - 느슨한 결합은 시스템의 각 모듈이나 컴포넌트들이 서로 의존성을 최소화하여 독립적으로 작동하는 것임
  - 높은 응집력은 모듈 내의 구성 요소들이 하나의 관련된 작업을 수행하도록 하는 원리임
- **특징**: 
  - 느슨한 결합은 모듈 간의 의존도가 낮아 수정이나 교체가 용이하고, 시스템의 유연성과 확장성을 높임
  - 높은 응집력은 한 모듈이 하나의 책임만을 가지므로 유지보수 및 테스트가 용이함

**확장성 및 성능(Scalability and Performance)**

- **정의**: 
  - 확장성은 시스템이 커지거나 부하가 증가할 때 성능이나 처리 능력을 추가하여 확장할 수 있는 능력을 의미함. 
  - 성능은 시스템이 주어진 작업을 얼마나 효율적으로 처리할 수 있는지에 대한 측정하는 것임
- **특징**:
  - 시스템이 높은 트래픽이나 처리 요구 사항을 처리할 수 있도록 확장하는 데 필요한 자원이나 방법을 설계하여 확장성을 고려함
  - 시스템이 최대한 빠르고 효율적으로 작업을 처리하도록 최적화하여 성능을 고려함

**회복성과 내결함성(Resilience to Fault Tolerance)**

- **정의**: 
  - 회복성은 시스템이 고장이나 오류 상황에서 얼마나 잘 회복할 수 있는지를 의미하고, 내결함성은 시스템이 오류가 발생해도 지속적으로 정상 동작을 할 수 있도록 설계하는 능력임
- **특징**: 
  - 시스템이 장애에 강하게 설계되어 있으며, 장애가 발생하더라도 복구 절차가 마련되어 있어 서비스 중단을 최소화할 수 있음
  - 

**개인정보 보호 및 보안(Security and Privacy)**

- **정의**: 
  - 보안은 시스템과 데이터를 외부 공격이나 침해로부터 보호하는 기술과 절차를 의미함
- **특징**: 
  - 시스템은 비인가 접근을 방지하고, 데이터의 무결성과 기밀성을 보장함
  - 개인정보 보호를 위해서는 암호화, 익명화, 접근 제어 등의 방법을 통해 개인 정보를 보호함


# 명령어 집합 구조(ISA, Instruction Set Architecture)

## CISC (Complex Instruction Set Computer)

- **정의**: 
  - 복잡하고 다양한 명령어를 포함하는 명령어 집합 구조를 가진 컴퓨터 아키텍처
- **특징**: 
  - 가변 길이 명령어를 가질 수 있어 명령어의 복잡성과 다양성을 증가시킴, 이를 통해 더 많은 기능을 하나의 명령어로 구현
  - 다양한 주소 지정 방식을 지원하여 데이터 접근 방법의 유언성을 제공하고, 복잡한 데이터 구조를 쉽게 처리 가능함

- **장점**: 
  - 복잡한 명령어를 사용하여 작업을 수행하는데 필요한 명령어 수가 줄어들어 코드의 밀도가 높아질 수 있음
  - 많은 기능을 하나의 명령어로 구현할 수 있어, 하드웨어의 복잡성을 숨기고 추상화된 인터페이스를 제공할 수 있음

- **단점**: 
  - 복잡한 명령어 집합과 마이크로코드의 사용으로 CPU설계가 복잡해짐
  - 명렁어가 복잡하고 길이가 가변적이기 때문에, 효율적인 파이프라이닝을 구현하기 어려움
  - 하드웨어가 복잡한 명령어를 처리해야 하기 때문에, RISC에 비해 명령어의 실행 속도가 느림

- **활용 예시**: 
  - Intel x86 아키텍처 CPU, AMD x86 호환 CPU, 모토로라 68000 시리즈, IBM 메인프레임 CPU 등

## RISC (Reduced Instruction Set Computer)

- **정의**: 
  - 단순하고 고속의 명령어 집합을 사용하는 컴퓨터 아키텍처
- **특징**: 
  - 명령어의 복잡성을 줄여 단순한 구조로 설계되고, 명령어 길이가 고정되어 있음
  - 레지스터를 적극적으로 사용하여 메모리 접근을 최소화 함
  - 데이터 메모리에 접근하는 명령어(로드/스토어)와 데이터 레지스터간의 연산을 분리하여 처리함
  
- **장점**: 
  - 단순하고 고정된 명령어 구조로, 파이프라이닝을 효과적으로 구현할 수 있음
  - 복잡한 명령어 처리가 필요 없기 때문에, 전력 소비가 적고, 에너지 효율성이 높아 모바일 및 임베디드 시스템에 적합함

- **단점**: 
  - 하나의 복잡한 명령어를 여러 단순한 명령어로 구현해야 하기 때문에, 전체 명령어 수가 증가하여 코드의 길이가 길어질 수 있음
  - 데이터 메모리에 접근하는 명령어가 별도로 존재하기 때문에, 복잡한 메모리 연산을 직접 지원하지 않음
  - 많은 레지스터를 필요로 해서 하드웨어 설계가 복잡하고, 레지스터 수가 제한적일 경우 성능 저하로 이어질 수 있음

- **활용 예시**: 
  - Apple A시리즈 칩, Qualcomm Snapdragon 시리즈, AWS Graviton 프로세서 등

# 데이터 표현 및 연산 (Data Representation and Operations)

## 수의 체계 (Number Systems)
- 컴퓨터는 우리가 흔히 일생상활에서 사용하는 10진수가 아닌, 2진수, 8진수와 16진수를 사용
- 컴퓨터는 전자 신호의 ON(1)과 OFF(0) 상태를 기반으로 작동하기 때문에 2진법 기반의 숫자 체계를 사용

### 이진수(Binary), 8진수(Octal), 16진수(Hexadecimal) 표현

**이진수(Binary)**

- **정의**: 
  - 0과 1 두 가지 숫자만을 사용하여 수를 표현하는 체계
- **특징**: 
  - 각 자릿수가 하나의 bit이며, 2의 거듭제곱수를 나타냄
  - $n$개 자릿수를 가진 이진수라면 $2^0$부터 시작하여 $2^{n-1}$까지가 각 자릿수에 대응함
- **활용 예시**: 
  - 2진수 $1001$을 10진수로 변환하면 $1*2^3 + 0*2^2 + 0*2^1 + 1*2^0$으로 $9$
  - 10진수 $7$을 2진수로 변환하면 $1*2^2 + 1*2^1 + 1*2^0$이므로 $111₂$

**8진수(Octal)**

- **정의**: 
  - 0부터 7까지 8개의 숫자를 사용하여 수를 표현하는 체계
- **특징**: 
  - 8진수 한 자릿수가 2진수 3bit와 대응하며, 8의 거듭제곱수를 나타냄
  - $n$개 자릿수를 가진 8진수라면 $8^0$부터 시작하여 $8^{n-1}$까지가 각 자릿수에 대응함
- **활용 예시**: 
  - 8진수 $101$을 10진수로 변환하면 $1*8^2 + 0*8^1 + 1*8^0$으로 $65$
  - 10진수 $18$을 8진수로 변환하면 $2*8^1 + 2*8^0$이므로 $22₈$

**16진수(Hexadecimal)**

- **정의**: 
  - 0부터 9까지와 A부터 F(A : 10 ~ F : 15)까지 6개의 문자, 총 16개의 숫자로 수를 표현하는 체계
- **특징**: 
  - 각 자릿수가 2진수 4bit에 대응하며, 16의 거듭제곱수를 나타냄
  - $n$개 자릿수를 가진 16진수라면 $16^0$부터 시작하여 $16^{n-1}$까지가 각 자릿수에 대응함
- **활용 예시**: 
  - 16진수 FA를 10진수로 변환하면 $F(15)*16^1 + A(10)*16^0$으로 $250₁₆$
  - 10진수 $720$를 16진수로 변환하면 $2*16^2 + D(13)*16^1 + 0*16^0$이므로 $2D0₁₆$


### 체계 간 변환

**2진수 - 8진수 변환**
  - 8진수의 한 자리가 2진수의 3bit에 대응하므로 2진수를 오른쪽부터 세자리씩 끊어서 8진수로 변환한 후 순서대로 결합
  - 8진수를 2진수로 변환할때는 8진수 한 자리를 2진수 3bit로 변환한 후 순서대로 결합
  - 예시
    - 2진수 $1 101 011$을 8진수로 변환하면 $001 | 101 | 011$ -> $1 | 5 | 3$ 이므로 $153$
    - 8진수 $161$을 2진수로 변환하면 $1 | 6 | 1$ -> $001 | 110 | 001$ 이므로 $1110001$

**2진수 - 16진수 변환**
  - 16진수의 한 자리가 2진수의 4bit에 대응하므로 2진수를 오른쪽부터 네자리씩 끊어서 16진수로 변환한 후 순서대로 결합
  - 16진수를 2진수로 변환할때는 16진수 한 자리를 2진수 4bit로 변환한 후 순서대로 결합
  - 예시 
    -  2진수 $111 0010 1001$을 16진수로 변환하면 $0111|0010|1001$ -> $7|2|9$이므로 $729$
    -  16진수 $C A 8$을 2진수로 변환하면 $C|A|8$ -> $1101|1010|1000$이므로 $110110101000$

**8진수 - 16진수 변환**
- 8진수에서 16진수로 변환할때는, 8진수를 2진수로 변환 후 16진수로 변환
- 16진수를 8진수로 변환할때는, 16진수를 2진수로 변환 후 8진수로 변환


## 정수와 실수 표현 (Integer and Floating-Point Representation)

**정수(Integer)**

- **정의**: 
  - 숫자를 표현하기 위한 데이터 타입 중 하나로, 소수점 없는 숫자를 저장하고 처리함
- **특징**: 
  - 양의 정수, 음의 정수, 그리고 0을 포함함

**실수(Real Number)**

- **정의**: 
  - 소수점 이하의 값을 포함할 수 있는 숫자 집합임
- **특징**: 
  - 유리수(rational number)와 무리수(irrational number)를 포함하는 수의 집합임

### 고정소수점과 부동소수점

**고정소수점 (Fixed Point)**

- **정의**: 
  - 소수점의 위치가 고정되어 있는 숫자 표현 방식
- **특징**: 
  - 부호 비트와 정수 부분을 나타내는 정수부, 소수 부분을 나타내는 소수부로 구성됨
  - 고정된 자리 수로 인해 특정 숫자를 정확하게 표현할 수 있음
- **장점**: 
  - 소수점 위치가 고정되어 있어 연산이 단순하고, 복잡한 부동소수점 유닛이 필요하지 않아 부동소수점에 비해 연산이 빠름
  - 정수부와 소수부의 비트 수가 고정되어 있기 때문에, 메모리 사용이 예측 가능하고 최적화 될 수 있음
- **단점**: 
  - 표현할 수 있는 숫자의 범위가 좁아서 큰 숫자나 소수를 표현하기 어려움
  - 부동소수점에 비해 소수부 정밀도가 낮음
- **활용 예시**: 
  - 고정 소수점의 소수부 구하는 법
    - 10진수를 2진수로 변환하는 방법의 반대로 2를 곱해가며 나머지를 구해 결합함
      - $0.625$를 2진수로 변환하기
        - $0.625 * 2 = 1.25$ -> 나머지 $1$을 제외하고 다음 계산함
        - $0.25 * 2 = 0.5$ -> 나머지 $0$을 제외하고 다음 계산함
        - $0.5 * 2 = 1$ -> 나머지 $1$을 제외함
        - 0.625의 고정소수점 변환 소수부는 $101$

**부동소수점 (Floating Point)**

- **정의**: 
  - 소수점 위치가 고정되어 있지 않고, 숫자의 크기에 따라 소수점 위치가 이동하는 표현 방식
- **특징**: 
  - 부호 비트와 지수를 나타내는 지수부, 소수점 아래를 나타내는 가수부로 구성됨
  - 부동소수점 수는 항상 정규화(Normalization)된 형태로 표현 - 가수가 1.F형태를 가지도록 조정되어 표현함
  - IEEE 754 표준을 통해 32비트(단정도, Single Precision), 64비트(배정도, Double Precision)를 사용하여 실수를 표현함
  - 지수부에 bias를 더하여 지수부가 10진수 기준으로 0~127구간은 음수, 128~255구간은 양수를 나타내어 음의 지수를 표현함
- **동작 방식**: 
- **장점**: 
  - 소수점 위치를 조정함으로써, 매우 큰 수부터 매우 작은 수까지 표현 가능함
  - 높은 정밀도를 가져 복잡한 수학적 연산이나 데이터 분석에서 고정소수점에 비해 정확한 결과를 얻을 수 있음
  - IEEE 754표준을 통해 부동소수점 연산의 일관성을 보장하여, 다양한 컴퓨터 시스템과 프로그래밍 언어 간 호환성이 높음
- **단점**: 
  - 고정소수점 연산에 비해 복잡하고 많은 자원을 소모할 수 있음
  - 유한한 비트 수로 실수를 표현하기 때문에, 모든 실수를 정확하게 표현할 수 없음
- **활용 예시**: 
  - $6.5$를 단정도 부동소수점으로 변환 - 1비트는 부호 비트로 사용, 지수부 8비트, 가수부 23비트로 구성
    - $6$ -> $110$
    - $0.5$ -> $1$
    - $6.5$ -> $110.1$
    - 정규화하여 $1.101 * 2^2$
    - 양수이므로 부호 비트는 0, 지수가 양수이므로 bias를 더하고 오른쪽부터, 가수부는 소수점 아래를 왼쪽부터 채워 $0 | 10000001 | 10100000000000000000000$으로 표현(정수 1은 모든 부동소수점 표현에서 같이 존재하므로 무시)


### IEEE 754 표준 (IEEE 754 Standard) - 표현, 정밀도, 반올림

**IEEE 754 표준 (IEEE 754 Standard)**

- **정의**: 
  - 컴퓨터에서 부동소수점 수를 표현하고 연산하는 방식을 규정한 국제 표준
- **특징**: 
  - 부동소수점을 단정도와 배정도 두 가지 형식으로 정의함
    - 단정도(Single Precision, 32bit)
      - 부호 비트 1비트, 지수 비트 8비트, 가수 비트 23비트
    - 배정도(Double Precision, 64bit)
      - 부호 비트 1비트, 지수 비트 11비트, 가수 비트 52비트
  - 특수 값을 따로 정의 하여 특수한 상황을 처리
    - Zero
      - 양의 제로 - 부호 비트 0, 지수 비트 모두 0, 가수 비트 모두 0
      - 음의 제로 - 부호 비트 1, 지수 비트 모두 0, 가수 비트 모두 0
    - Infinity
      - 양의 무한대 - 부호 비트 0, 지수 비트 모두 1, 가수 비트 모두 0
      - 음의 무한대 - 부호 비트 1, 지수 비트 모두 1, 가수 비트 모두 0
    - NaN(Not a Number)
      - 지수 비트 모두 1, 가수 비트 모두 0

**정밀도**

- **정의**: 
  - 부동소수점 수가 얼마나 정확하게 실수를 표현할 수 있는가를 나타냄
- **특징**: 
  - IEEE 754 표준에서는 단정도와 배정도로 정밀도를 구분함
    - 단정도
      - 가수 비트 23비트로 약 7자리 십진수를 표현 가능
    - 배정도
      - 가수 비트 52비트로 약 16자리 십진수를 표현 가능

**반올림**

- **정의**: 
  - 부동 소수점 연산에서 발생할 수 있는 반올림을 다루기 위한 다양한 방법
- **특징**:
  - 부동 소수점 연산의 결과가 표현 가능한 정밀도를 초과할 때 사용함
  - 연산 결과가 가수부의 비트를 초과할 때 반올림 모드를 이용해 연산 결과를 표현
  - IEEE 754에서는 round to nearest, ties to even을 기본값으로 사용

  - 반올림 모드(Rounding mode)
    - 짝수로 반올림(round to nearest, ties to even)
      - 반올림하려는 수의 소수부분이 정확히 0.5일 경우, 소수부분의 앞 자리 정수가 짝수인 경우 가장 가까운 작은 정수로 반올림, 앞자리 숫자가 홀수라면 가장 가까운 큰 정수로 반올림
      - $4.5$의 반올림은 $4$, $5.5$의 반올림은 $6$
    - 큰 절댓값으로 반올림(round to nearest, ties away from zero)
      - 반올림하려는 수의 소수부분이 정확히 0.5일 경우, 소수부분의 앞 자리 정수에 관계없이 가장 가까운 정수 쪽으로 반올림
      - $4.5$의 반올림은 $5$, $5.5$의 반올림은 $6$
    - 올림(round toward +∞)
      - 반올림하려는 수가 양의 무한대에 가까워지는 경우, 해당 양의 무한대 값을 반올림 결과로 사용(가장 가까운 큰 정수)
      - $3.2$의 반올림은 $4$, $5.7$의 반올림은 $6$
    - 버림(round toward -∞)
      - 반올림하려는 수가 음의 무한대에 가까워지는 경우, 해당 음의 무한대 값을 반올림 결과로 사용(가장 가까운 작은 정수)
      - $3.7$의 반올림은 $3$, $-2.8$의 반올림은 $-3$
    - 절삭(round toward zero)
      - 반올림하려는 수의 소수 부분을 무시하고, 가장 가까운 정수로 반올림
      - $2.9$의 반올림은 $2$, $-2.9$의 반올림은 $-2$
- **활용 예시**: 


## 데이터 연산 (Data Operations)

### 산술 연산 (Arithmetic Operations)

**산술 연산 (Arithmetic Operations)**

- **정의**: 
  - 숫자에 대한 기본적인 수학적 연산으로, 일반적으로 정수 및 부동 소수점 수에 대해 수행됨
- **특징**: 
  - 기본적인 사칙연산 덧셈, 뺄셈, 곱셈, 나눗셈을 수행함
  - 오버플로우, 언더플로우와 같은 문제를 처리하기 위한 추가적인 논리가 필요함
- **동작 예시**:
- 종류
  - 덧셈(+)
    - 두 숫자를 더하는 연산
    - $3 + 5 = 8$
  - 뺄셈(-)
    - 한 숫자에서 다른 숫자를 빼는 연산
    - $5 - 3 = 2$
  - 곱셈(*)
    - 두 숫자를 곱하는 연산
    - $3 * 5 = 15$
  - 나눗셈(/)
    - 한 숫자를 다른 숫자로 나누는 연산
    - $15 / 3 = 5$
  - 모듈로 연산(%)
    - 한 숫자를 다른 숫자로 나누고 나머지를 구하는 연산
    - $20 \% 3 = 2$ 
- **장점**: 
  - 다양한 분야에서 활용 가능함
  - 복잡한 수학적 문제도 해결 가능함
- **단점**: 
  - 보동 소수점 연산에서 정밀도 문제가 존재함
  - 오버플로우 및 언더플로우 발생 가능성이 존재함
- **활용 예시**: 
  - 수학적 계산

### 논리 연산 (Logical Operations)

**논리 연산 (Logical Operations)**

- **정의**: 
  - Boolean 데이터를 처리하는 연산으로 조건 판단에 주로 사용함
- **특징**: 
  - 비트에 적용하여 비트 연산(Bitwise Operations)으로 사용함
  - 비트에서 참(True)는 1, 거짓(False)는 0으로 표현함
  - 단일 클록 주기 내에 처리될 수 있음
- **동작 예시**: 
  - 논리곱(AND)
    - 두 논리값이 모두 참일 때만 참을 반환
    - True AND False = False
    - True AND True = True
  - 논리합(OR)
    - 두 논리값 중 하나라도 참일 때 참을 반환
    - True OR False = True
  - 부정(NOT)
    - 논리값을 반대로 반환
    - NOT True = False
  - 배타적 논리합(XOR, Exclusive OR)
    - 두 값이 서로 다를 때 참을 반환
    - True XOR True = False
    - True XOR False = True
  - 부정 논리곱(NAND)
    - 논리곱 연산의 결과를 반대로 반환
    - True NAND False = True
    - True NAND True = False
  - 부정 논리합(NOR)
    - 논리합 연산의 결과를 반대로 반환
    - True NOR False = False
- **장점**: 
  - 연산 속도가 매우 빠름
  - 비트 마스크와 결합하여 효율적인 비트 단위의 데이터 처리가 가능함
- **단점**:
  - 복잡한 수학적 계산에는 한계가 있음
- **활용 예시**: 
  - 비트 마스크 설정, 해제, 검사

### 시프트 연산 (Shift Operations)

**시프트 연산 (Shift Operations)**

- **정의**: 
  - 2진수로 표현된 데이터를 특정 방향으로 일정한 비트 수만큼 이동시키는 연산
- **특징**: 
  - 2의 제곱수로 곱하거나 나누는 연산을 빠르게 수행할 수 있고, 특정 비트를 추출하거나 설정할 때 사용
  - 크게 논리 시프트, 산술 시프트, 순환 시프트로 나뉨
- **동작 예시**: 
  - 논리 시프트(Logical Shift)
    - 비트를 단순히 왼쪽이나 오른쪽으로 이동시키고, 이동한 자리에 0을 채우는 연산
    - 부호 비트를 유지하지 않아 주로 Unsigned 데이터에서 사용
    - 논리 시프트 왼쪽(Logical Shift Left, LSL) - Unsinged
      - 데이터를 왼쪽으로 이동시키고, 오른쪽 끝에 0을 채움
      - $69 << 1 = 138$ -> ($01000101$ -> $10001010$)
    - 논리 시프트 오른쪽(Logical Shift Right, LSR) - Unsinged
      - 데이터를 오른쪽으로 이동시키고, 오른쪽 끝에 0을 채움
      - $22 >> 1 = 11$ -> ($00010110$ -> $00001011$)
  - 산술 시프트(Arithmetic Shift)
    - 부호 비트를 유지하면서 비트를 이동시키는 연산
    - 주로 Signed 데이터에서 사용하며, 2의 거듭제곱수를 곱하거나 나누는데 사용
    - 산술 시프트 왼쪽(Arithmetic Shift Left, ASL) - 부호 절댓값 표현
      - $-33 << 1 = -66$ -> ($10100001$ -> $11000010$)
    - 산술 시프트 오른쪽(Arithmetic Shift Right, ASR) - 부호 절댓값 표현
      - $-33 >> 1 = -16$ -> ($10100001$ -> $10010000$)
  - 순환 시프트(Circular Shift)
    - 이동되어 제거된 비트가 다시 반대쪽 끝으로 순환되어 돌아오는 연산
    - 순환 시프트 왼쪽(Circular Shift Left, CSL) - Unsinged
      - $149 << 1 = 43$ -> ($10010101$ -> $00101011$)
    - 순환 시프트 오른쪽(Circular Shift Right, CSR) - Unsinged
      - $139 >> 1 = 197$ -> ($10001011$ -> $11000101$)
- **장점**: 
  - 하드웨어에서 산술 연산을 매우 빠르게 수행할 수 있음
  - 배수 및 나누기 연산에 특화되어, 효율적이고 빠른 계산 가능함
- **단점**: 
  - 연산 시 오버플로우 문제가 발생 할 수 있음
- **활용 예시**: 
  - 비트 마스크 및 플래그 설정
  - Gray 코드 변환

## Signed vs Unsigned 데이터

**Signed Data**

- **정의**: 
  - 양수와 음수 둘 다 표현할 수 있는 데이터 타입으로, 최상위 비트(MSB, Most Significant Bit)를 부호 비트로 사용하여 숫자의 부호를 표현
- **특징**: 
  - N비트의 signed 정수는 $-2^N \sim 2^N -1$ 까지의 수를 표현할 수 있음
  - 부호 비트 0은 양수, 1은 음수를 표현함
  - 3가지 음수 표현 방식이 존재함

    - 부호-절댓값(Sign-Magnitude)
      - 정수의 부호(Sign)와 크기(Magnitude)를 별도로 저장하는 방식임
      - 부호 비트 1비트를 제외한 나머지 비트에 절댓값을 2진수로 표현함
      - $+5$ -> $0 | 0000101₂$
      - $-5$ -> $1 | 0000101₂$
    - 1의 보수(One's Complement)
      - 음수를 표현하기 위해 양수의 모든 비트를 반전시키는 방식임
      - $+5$ -> $00000101₂$
      - $-5$ -> $11111010₂$
    - 2의 보수(Two's Complement)
      - 음수를 표현하기 위해 양수의 1의 보수에 1을 더하는 방식임
      - 현대의 대부분의 컴퓨터 시스템에서 사용
      - $+5$ -> $00000101₂$ 
      - $-5$ -> $11111011₂$ 

**Unsigned Data**

- **정의**:
  - 양수와 0만을 표현할 수 있는 데이터 타입
- **특징**:
  - N비트의 Unsigned 정수는 $0 \sim 2^N -1$까지의 수를 표현할 수 있음
  - 모든 비트를 숫자의 절댓값을 표현하는데 사용해, 동일한 비트 수에서 Signed보다 더 큰 양수를 표현할 수 있음
-  **예시**:
   - $11111101₂$는 253을 나타냄